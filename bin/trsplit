eval 'exec perl -S $0 ${1+"$@"}'
    if 0;
#
# Contributed by Giao Nguyen, http://daedalus.cs.berkeley.edu/~gnguyen
#

sub Usage
{
    $0 =~ s/.*\/([^\/]+)$/$1/;
    print <<EOF;
Split ns trace file into files for individual connection
Usage:  $0 [options] files
options: -d   delim:  deliminator for spliting the data fields or columns
	 -c comment:  comment to print at the end along with total throughput
	 -f	:  force new file for each connection
	 -psize size of packet in bytes
	 -tt	trace type
	 -pt	packet type
	 -ctt	trace type column
	 -cpt	packet type column
	 -ctime	time column
	 -csrc	source address column
	 -cdst	destination address column
EOF
    exit;
}

sub ParseArgv
{
    local($val);
    &Usage if ($#ARGV < 0);
    while ($_ = $ARGV[0], /^-/) {
	shift @ARGV;
	if (/^-d$/) {
	    $delim = shift @ARGV;
	}
	elsif (/^-pt$/) {
	    $val = shift @ARGV;
	    $pt = $pt ? $pt . " $val" : $val;
	}
	elsif (/^-(tt|pt|c|psize|ctt|cpt|ctime|csrc|cdst)$/) {
	    $val = shift @ARGV;
	    s/-(\w+)/\$$1/;
	    eval "$_ = '$val'";
	}
	elsif (/^-(f)$/) {
	    s/-(\w+)/$1/;
	    $opt{$_} = 1;
	}
	else {
	    last;
	}
    }
}


$delim = " ";
$psize = 1000;
$tt = '-';
$ctt = 1;
$ctime = 2;
$csrc = 9;
$cdst = 10;
$cpt = 5;
$cseq = 11;

&ParseArgv;
$pt = 'tcp'  if !$pt;
$ctt--; $ctime--;
$cpt--; $csrc--; $cdst--; $cseq--;

$fidcount = 4;

while (<>)
{
    chop;
    @col = split(/$delim/);
    next if ($col[0] ne $tt);
    next if !grep(/$col[$cpt]/, $pt);

    $src = $col[$csrc];
    $dst = $col[$cdst];
    $key = "$col[$cpt].$src.$dst";
    $time{$key} = $col[$ctime];
    $seqno{$key} = $col[$cseq];

    if ($opt{f}) {
	$fid = $opened{$key};
	if (! $fid) {
	    $opened{$key} = $fid = $fidcount++;
	    open($fid, ">$ARGV.$key");
	}
	printf $fid "%0.6f\t%d\n", $col[$ctime], $col[$cseq];
    }
}

@keys = sort (keys %time);
foreach $key (@keys) {
    $t = $time{$key};
    $s = $seqno{$key};
    $maxtime = $t  if ($t > $maxtime);
    $maxpkt += $s;
    printf("%s\t%0.6f\t%d\t%0.6f\t%0.6f\n",
	   $key, $t, $s, $s/$t, 0.008 * $psize * $s/$t);
}

if ($maxtime > 0) {
    printf STDERR " %d\t%0.6f\t%s\n",
	$#keys+1, 0.008 * $psize * $maxpkt / $maxtime, $c;
}
