.\"
.\" Copyright (c) 1994-1995 Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgment:
.\"	This product includes software developed by the Computer Systems
.\"	Engineering Group at Lawrence Berkeley Laboratory.
.\" 4. Neither the name of the University nor of the Laboratory may be used
.\"    to endorse or promote products derived from this software without
.\"    specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.TH NS 1 "25 July 1997"
.de HD
.sp 1.5
.B
..
.SH NAME
ns \- network simulator (version 2)
.SH SYNOPSIS
.na
.B ns
[
.I file
[
.I arg arg ...
]
]
.ad

.SH DESCRIPTION

.I ns 
is an event-driven network simulator.
An extensible simulation engine 
is implemented in C++ 
that uses MIT's Object Tool Command Language, OTcl
(an object oriented version of Tcl)
as the command and configuration interface.
A previous version of the simulator 
i.e. ns version 1 used
the Tool Command Language, Tcl 
as the configuration language.
The current version still supports
simulation scripts written in Tcl
meant for the ns version 1 simulator.
.LP
The simulator is invoked via the
.I ns
interpreter, an extension of the vanilla
.I otclsh
command shell.
A simulation is defined by a OTcl script.
The scripts use the Simulator Class
as the principal interface 
to the simulation engine.
Using the methods defined in this class, 
a network topology is defined, 
traffic sources and sinks are configured, 
the simulation is invoked,
and the statistics are collected.
By building upon a fully functional language, arbitrary actions
can be programmed into the configuration.  
.LP
The first step in the simulation 
is to acquire
an instance of the Simulator class.
Instances of objects in classes 
are created and destroyed in ns using the
.I new
and
.I delete
methods.
For example, 
an instance of the Simulator object is
created by the following command:
.nf

	e.g. set ns [new Simulator]

.fi
A network topology is realized 
using three primitive building blocks:
nodes, links, and agents.  
The Simulator class has methods to create/
configure each of these building blocks.
Nodes are created with the
.I node
Simulator method
that automatically assigns
an unique address to each node.
Links are created between nodes
to form a network topology with the
.I simplex-link 
and 
.I duplex-link
methods that set up 
unidirectional and bidirectional links respectively.
Agents are the objects that
actively drive the simulation.
.I Agents 
can be thought of as the
processes and/or transport entities that
run on 
.I nodes
that may be end hosts or routers.
Traffic sources
and sinks, dynamic routing modules
and the various protocol modules
are all examples of agents.
Agents are created by
instantiating objects 
in the subclass of class Agent i.e., 
.I Agent/type
where type specifies 
the nature of the agent.
For example, a TCP agent
is created using the command:
.br
.nf

	set tcp [new Agent/TCP]

.fi
.LP
Once the agents are created,
they are
attached to nodes
with the 
.I attach-agent
Simulator method.
Each agent is automatically assigned a port number unique across
all agents on a given node (analogous to a tcp or udp port).
Some types of agents may
have sources attached to them 
while others may generate their own data.  
For example, 
you can attach ``ftp'' and ``telnet'' sources
to ``tcp'' agents 
but ``constant bit-rate'' agents generate their own data.
Sources are attached to agents
using the
.I attach-source
and
.I attach-traffic
agent methods.
.LP
Each object has
some configuration parameters associated with it
that can be modified.
Configuration parameters are 
instance variables of the object.
These parameters are initialized
during startup to default values
that can simply be read from the 
instance variables of the object.
For example,
.I $tcp set window_
returns the default window size for the tcp object.
The default values for that object
can be explicitly overridden by simple assignment
either before a simulation begins,
or dynamically, while the simulation is in progress.
For example the window-size for a particular TCP session 
can be changed in the
following manner.
.br
.nf

	$tcp set window_ 25

.fi
The default values for the 
configuration parameters
of all the class objects
subsequently created
can also be changed by simple assignment.
For example, we can say
.br
.nf

	Agent/TCP set window_ 30

.fi
to make all future tcp agent creations default to a window size of 30.
.LP
Events are scheduled in ns
using the
.I at
Simulator method
that allows OTcl procedures to be invoked
at arbitrary points in simulation time.
These OTcl callbacks provide a flexible simulation
mechanism -- they can be used to start or stop
sources, dump statistics, instantiate link failures,
reconfigure the network topology etc.
The simulation is started via the
.I run
method and continues until there are no more
events to be processed.
At this time,
the original invocation of the
.I run
command returns 
and the Tcl script can exit or invoke another
simulation run after possible reconfiguration.
Alternatively, the simulation can be prematurely halted 
by invoking the
.I stop
command or by exiting the script with Tcl's standard
.I exit
command.
.LP
Packets are forwarded along the shortest path route from
a source to a destination, where the distance metric is
the sum of costs of the links traversed from
the source to the destination.
The cost of a link is 1 by default;
the distance metric is
simply the hop count
in this case.
The cost of a link can be changed with the
.I cost
Simulator method.
A static topology model
is used as the default in ns
in which
the states of nodes/links
do not change during the course of a simulation.
Network Dynamics could be specified
using methods described in NETWORK DYNAMICS METHODS section.
Also static unicast routing is the default 
in which the routes are pre-computed over the
entire topology once prior to
starting the simulation.
Methods to enable and configure 
dynamic unicast and multicast routing
are described in the 
UNICAST ROUTING METHODS and
MULTICAST ROUTING METHODS sections respectively.


.SH "NS COMMANDS"

This section describes the basic commands 
to create the building blocks
of the simulation
(i.e. the node, link and agent objects)
and to run the simulation.
.LP
The first step in running a simulation
as stated before 
is to acquire an instance of the
Simulator class that has
methods to configure and run the simulation.
Throughout this section 
the object variable name $ns 
is used to imply a 
Simulator object.

.IP "\fB$ns node\fP"
Create a new node object and return a handle to it.

.IP "\fB$ns all-nodes-list\fP"
Returns a list of all the node objects defined in the simulation.

.IP "\fB$ns simplex-link\fI node1 node2 bw delay type\fP"
Create a new unidirectional link between
.I node1
and
.I node2
with bandwidth
.I bw
in bits per second
and link propagation delay
.I delay
in seconds.
.I node1
and
.I node2
must have already been created with the
.I node
method.
.I bw
and
.I delay
default to
1.5 Mbits/sec and 100 ms respectively.
The defaults can be changed by modifying 
the relevant configuration parameters of the 
DelayLink Object (see DELAYLINK OBJECTS section).
.I node1
and
.I node2
must have already been created with the
.I node
method.
The queuing discipline of the link is specified by
.I type,
which may be
.B DropTail,
.B FQ,
.B SFQ,
.B DRR,
.B RED,
.B CBQ,
or 
.B CBQ/WRR.
A DropTail link is a simple FIFO queue which drops the last packet
in the queue when the queue overflows.
A FQ link is for Fair Queuing (for details see [?]).
A SFQ link is for Stochastic Fair Queuing (for details see [?]).
A DRR link is for deficit round robin scheduling (for details see [9]).
A RED link is a random-early drop queue (for details see [2]).
A CBQ link is for class-based queuing using a packet-by-packet round-robin
scheduler (for details see [3]).
A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.
If multicast routing is used
links with interface labels are required.
Such links are created by 
setting Simulator NumberInterfaces_ variable to 1.
All the subsequently created links will have interface labels.
To disable creation of interfaces simply reset NumberInterfaces_ to 0
(this is the default).

.IP "\fB$ns duplex-link\fI node1 node2 bw delay type\fP"
Create a new bidirectional link between
.I node1
and
.I node2
with bandwidth
.I bw
in bits per second
and link propagation delay
.I delay
in seconds.
.I node1
and
.I node2
must have already been created with the
.I node
method.
.I bw
and
.I delay
default to
1.5 Mbits/sec and 100 ms respectively.
The defaults can be changed by modifying 
the relevant configuration parameters of the 
DelayLink Object (see DELAYLINK OBJECTS section).
The queuing discipline of the link is specified by
.I type,
which may be
.B DropTail,
.B FQ
.B SFQ,
.B DRR,
.B RED,
.B CBQ,
or 
.B CBQ/WRR.
A DropTail link is a simple FIFO queue which drops the last packet
in the queue when the queue overflows.
A FQ link is for Fair Queuing (for details see [?]).
A SFQ link is for Stochastic Fair Queuing (for details see [?]).
A DRR link is for deficit round robin scheduling (for details see [9]).
A RED link is a random-early drop queue (for details see [2]).
A CBQ link is for class-based queuing using a packet-by-packet round-robin
scheduler (for details see [3]).
A CBQ/WRR link is for class-based queuing with a weighted round robin scheduler.
If multicast routing is used
links with interface labels are required.
Such links are created by 
setting Simulator NumberInterfaces_ variable to 1.
All the subsequently created links will have interface labels.
To disable creation of interfaces simply reset NumberInterfaces_ to 0
(this is the default).

.IP "\fB$ns link\fI node1 node2\fP"
Returns a reference to the link connecting nodes
.I node1
and
.I node2.
This is useful for 
setting link configuration parameters
and to invoke tracing methods (see LINK OBJECTS section).

.IP "\fB$ns queue-limit\fI node1 node2 queue-limit\fP"
Set the maximum number of packets
that can be queued on the link
in the direction from
.I node1
to 
.I node2
to
.I queue-limit.
The link between node1 and node2
should have already been created.

.IP "\fB$ns delay\fI node1 node2 time-interval\fP"
Set the latency of the link
in the direction from
.I node1
to
.I node2 
to 
.I time-interval
seconds.
The link between node1 and node2
should have already been created.

.IP "\fB$ns cost \fI node1 node2 cost-val\fP"
Assign the cost
.I cost-val
to the link between nodes
.I node1
and
.I node2.
The costs assigned to links
are used in unicast route computations.
All the links default
to a cost of 1.

.IP "\fBnew Agent/\fItype\fP"
Create an Agent
of type
.I type
which may be:
.nf
  Null                  - Traffic Sink
  LossMonitor           - Traffic Sink that monitors loss parameters
  TCP                   - BSD Tahoe TCP
  TCP/Reno              - BSD Reno TCP
  TCP/Newreno           - a modified version of BSD Reno TCP
  TCP/Vegas             - Vegas TCP (from U. Arizonia via USC)
  TCP/Sack1             - BSD Reno TCP with selective ACKs
  TCP/Fack              - BSD Reno TCP with forward ACKs
  TCPSink               - standard TCP sink
  TCPSink/DelAck        - TCP sink that generates delayed ACKs
  TCPSink/Sack1         - TCP sink that generates selective ACKs
  TCPSink/Sack1/DelAck  - delayed-ack TCP sink with selective ACKs
  CBR                   - constant bit rate traffic source
  CBR/UDP               - UDP Transport
  CBR/RTP               - RTP agent
  Session/RTP           - 
  RTCP                  - RTCP agent
  IVS/Source            - 
  IVS/Receiver          - 
  SRM                   - 
.fi
The methods, configuration parameters 
and the relevant state variables
associated with these objects
are discussed in detail in later sections.
Note that some agents e.g. TCP or SRM
do not generate their own data.
Such agents need sources attached to them
to generate data
(see attach-source and attach-traffic methods 
in AGENT OBJECTS section).

.IP "\fB$ns attach-agent \fInode agent\fP"
Attach the agent object
.I agent
to
.I node.  
The
.I agent
and
.I node
objects should have already been created.

.IP "\fB$ns detach-agent \fInode agent\fP"
Detach the agent object
.I agent
from
.I node.

.IP "\fB$ns connect \fIsrc dst\fP"
Establish a two-way connection between the agent
.I src
and the agent
.I dst.
Returns the handle to
.I src
agent.
A helper method
has been defined to 
facilitate creating and attaching an agent
to each of two nodes
and establishing a two-way connection between them.
(see BUILTINS section).

.IP "\fB$ns use-scheduler \fItype\fP"
Use an event scheduler of type
.I type
in the simulations.
.I type
is one of List, Heap, Calendar, RealTime.
The List scheduler is the default. 
A Heap scheduler uses a heap for event queueing.
A Calendar scheduler uses a calendar queue to keep track of events.
RealTime scheduler is used in emulation mode when the simulator
interacts with an external agent.

.IP "\fB$ns at\fI time procedure\fP"
Evaluate
.I procedure
at simulation time
.I time.
The procedure could be a globally accessible function (proc) or an object
method (instproc).
This command can be used 
to start and stop sources, 
dynamically reconfigure the simulator,
dump statistics at specified intervals, etc.
Returns an event id.

.IP "\fB$ns cancel \fIeid\fP"
Remove the event specified by the event id
.I eid
from the event queue.

.IP "\fB$ns now\fP"
Return the current simulation time.

.IP "\fB$ns gen-map\fP"
Walks through the simulation topology
and lists all the objects
that have been created
and the way they are hooked up to each other.
This is useful to debug simulation scripts.

.IP "\fBns-version\fP"
Return a string identifying the version of ns currently running. 
This method is executed in 
the global context 
by the interpreter.
.IP "\fBns-random\fI [ seed ]\fP"
If
.I seed
is not present,
return a pseudo-random integer between 0 and 2^31-1.
Otherwise, seed the pseudo-random number generator with
.I seed
and return the seed used.
If
.I seed
is 0, choose an initial seed heuristically (which varies
on successive invocations).
This method is executed in
the global context
by the interpreter.

.SH "OBJECT HIERARCHY"

A brief description of 
the object hierarchy in
.I ns
is presented in this section.
This description is
not intended to be complete.
It has been provided to depict
how the methods and configuration parameters
associated with the various objects
are inherited.
For more complete information
see [ns internals document].
.LP
Objects are associated with 
configuration parameters that can be
dynamically set and queried,
and state variables that can be queried 
(usually modified only when the state variables need to be reset for
another simulation run).
.LP
Configuration parameters represent simulation parameters
that are usually fixed during the entire simulation (like a
link bandwidth), but can be changed dynamically if desired.
State variables represent values that are specific to a
given object and that object's implementation.
.LP
The following diagram depicts the object hierarchy:
.nf
    Simulator
          MultiSim
    Node
    Link
          SimpleLink
               CBQLink
          DummyLink     
    DelayLink
    Queue
          DropTail
          FQ
          SFQ
          DRR
          RED
          CBQ
          CBQ/WRR
    QueueMonitor
    rtObject
    RouteLogic
    Agent
          rtProto
               Static
               Session
               DV 
               Direct
          Null
          LossMonitor
          TCP
               Reno
               Newreno
               Sack1
               Fack
          TCPSink
               DelAck
               Sack1
                   DelAck
          CBR
               UDP
               RTP
          RTCP
          IVS
               Source
               Receiver
          SRM
          Session
               RTP [how is this diff from Agent/CBR/RTP]
    Source
          FTP
    Traffic
          Expoo
          Pareto
          Trace
    Integrator
    Samples
.fi
.LP
For example, any method that is supported by a
.I TCP
agent is also supported by a
.I Reno
or a
.I Sack1
agent.
Default configuration parameters are also inherited.
For example, 
.I $tcp set window_ 20
where $tcp is a TCP agent
defines the default TCP window size for both
.I TCP
and
.I Reno
objects.

.SH "OBJECT METHODS"
The following sections document the methods, configuration parameters
and state variables associated with the various objects 
as well as those to enable
Network dynamics, Unicast routing, Multicast routing and
Trace and Monitoring support.
The object class is specified implicitly by the object
variable name in the description.   
For example,
.B $tcp
implies the tcp object class and all of its child classes.

.SH "NODE OBJECTS"
.IP "\fB$node id\fP"
Returns the node id.
.IP "\fB$node neighbors\fP"
Returns a list of the neighbour node objects.
.IP "\fB$node attach \fIagent\fP"
Attach an agent of type
.I agent
to this node.
.IP "\fB$node detach \fIagent\fP"
Detach an agent of type
.I agent
from this node.
.IP "\fB$node agent \fIport\fP"
Return a handle to the agent attached to port
.I port
on this node.  Returns an empty string if the port is not in use.
.IP "\fB$node reset \fIport\fP"
Reset all agents attached to this node.
This would re-initialize the state variables
associated with the various agents
at this node.
.IP "\fB$node rtObject?\fP"
Returns a handle to rtObject
if there exists an instance
of the object at that node.
Only nodes that take part in
a dynamic unicast routing protocol
will have this object 
(see UNICAST ROUTING METHODS and RTOBJECT OBJECTS section).
.IP "\fB$node join-group \fIagent group\fP"
Add the agent specified by the object handle
.I agent
to the multicast host group identified by the address
.I group.
This causes the group membership protocol to arrange for the appropriate
multicast traffic to reach this agent.
Multicast group address should be 
in the range 0x8000 - 0xFFFF.
.IP "\fB$node allocaddr\fP"
Returns multicast group address
in ascending order 
on each invocation
starting from 0x8000
and ending at 0xFFFF.
.LP
There are no state variables or configuration parameters
specific to the node class.

.SH "LINK OBJECTS"
.IP "\fB$link trace-dynamics \fIns fileID\fP"
Trace the dynamics of this link
and write the output to
.I fileID
filehandle.
.I ns
is an instance of the Simulator or MultiSim object
that was created to invoke the simulation
(see TRACE AND MONITORING METHODS section 
for the output trace format).

.SH "SIMPLELINK OBJECTS"
.IP "\fB$link cost \fIcost-val\fP"
Make 
.I cost-val
the cost of this link.
.IP "\fB$link cost?\fP"
Return the cost of this link.
.LP
Any configuration parameters or state variables?

.SH "DELAYLINK OBJECTS"
The DelayLink Objects determine
the amount of time required for a packet to
traverse a link.
This is defined to be
size/bw + delay
where
size is the packet size,
bw is the link bandwidth and
delay is the link propagation delay.
There are no methods or state variables associated with this object.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIbandwidth_\fP
Link bandwidth in bits per second.
.IP \fIdelay_\fP
Link propagation delay in seconds.
.LP
There are no state variables associated with this object.

.SH "NETWORK DYNAMICS METHODS"
This section describes methods
to make the
links and nodes 
in the topology
go up and down
according to various distributions.
A dynamic routing protocol should
generally be used whenever 
a simulation is to be done
with network dynamics.
Note that a static topology model
is the default in ns.
.IP "\fB$ns rtmodel \fImodel model-params node1 [node2]\fP"
Make the link between
.I node1
and
.I node2
change between up and down states
according to the model
.I model.
In case only
.I node1
is specified all the links 
incident on the node
would be brought up and down
according to the specified
.I model.
.I model-params
contains the parameters required for the relevant model
and is to be specified as a list
i.e. the parameters are to be 
enclosed in curly brackets.
.I model
can be one of
.I Deterministic,
.I Exponential,
.I Manual,
.I Trace.
Returns a handle to a model object
corresponding to the specified
.I model.

In the Deterministic model
.I model-params
is
.I [start-time] up-interval down-interval [finish-time].
Starting from
.I start-time
the link is made up for
.I up-interval
and down for
.I down-interval
till
.I finish-time
is reached.
The default values for
start-time, up-interval, down-interval
are 0.5s, 2.0s, 1.0s respectively.
finish-time defaults to the end of the simulation.
The start-time defaults to 0.5s
in order to let the
routing protocol computation quiesce.

If the Exponential model is used
.I model-params
is of the form
.I up-interval down-interval
where the link up-time
is an exponential distribution
around the mean
.I up-interval
and the link down-time
is an exponential distribution
around the mean
.I down-interval.
Default values for
.I up-interval
and
.I down-interval
are 10s and 1s respectively.

If the Manual distribution is used
.I model-params 
is
.I at op
where
.I at
specifies the time at which the operation
.I op
should occur.
.I op
is one of
.I up, down.
The Manual distribution 
could be specified alternately using the
.I rtmodel-at 
method described later in the section.

If Trace is specified as the
.I model
the link/node dynamics
is read from a Tracefile.
The
.I model-params
argument would in this case
be the file-handle of the
Tracefile that has
the dynamics information.
The tracefile format is identical
to the trace output generated by
the trace-dynamics link method
(see TRACE AND MONITORING METHODS SECTION).

.IP "\fB$ns rtmodel-delete \fImodel-handle\fP"
Delete the instance of
the route model specified by
.I model-handle.

.IP "\fB$ns rtmodel-at \fIat op node1 [node2]\fP"
Used to specify the up and down times
of the link between nodes
.I node1
and 
.I node2.
If only
.I node1
is given all the links
incident on 
.I node1
will be brought up and down.
.I at
is the time
at which 
the operation
.I op
that can be either
.I up
or
.I down
is to be performed
on the specified link(s).

.SH "QUEUE OBJECTS"
A queue object is a general class of object capable
of holding and possibly marking or discarding packets as they
travel through the simulated topology.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIlimit_\fP
The queue size in packets.
.IP \fIblocked_\fP
Set to false by default,
this is true if the queue is blocked (unable to send
a packet to its downstream neighbor).
.IP \fIunblock_on_resume_\fP
Set to true by default, indicates a queue should unblock
itself at the time the last packet packet sent has been
transmitted (but not necessarily received).

.SH "DROP-TAIL OBJECTS"
Drop-tail objects are a subclass of Queue objects that implement simple
FIFO queue.  There are no methods, configuration parameter,
or state variables that are specific to drop-tail objects.

.SH "FQ OBJECTS"
FQ objects are a subclass of Queue objects that implement
Fair queuing.  There are no methods
that are specific to FQ objects.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIsecsPerByte_\fP
.LP
There are no state variables associated with this object.

.SH "SFQ OBJECTS"
SFQ objects are a subclass of Queue objects that implement
Stochastic Fair queuing.  There are no methods
that are specific to SFQ objects.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fImaxqueue_\fP
.IP \fIbuckets_\fP
.LP
There are no state variables associated with this object.

.SH "DRR OBJECTS"
DRR objects are a subclass of Queue objects that implement deficit
round robin scheduling. These objects implement deficit round robin
scheduling amongst different flows ( A particular flow is one which
has packets with the same node and port id OR packets which have the
same node id alone. A command-line argument "setmask" can be used to
decide what defines a particular flow). Also unlike other multi-queue
objects, this queue object implements a single shared buffer space for
its different flows.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIbuckets_\fP
Indicates the total number of buckets to be used for hashing each of
the flows.
.IP \fIblimit_\fP
Indicates the shared buffer size in bytes.
.IP \fIquantum_\fP
Indicates (in bytes) how much each flow can send during its turn.
.IP \fImask_\fP
mask_, when set to 1, means that a particular flow consists of packets
having the same node id (and possibly different port ids), otherwise a
flow consists of packets having the same node and port ids.


.SH "RED OBJECTS"
RED objects are a subclass of Queue objects that implement
random early-detection gateways.  The object can be configured
to either drop or ``mark'' packets.
There are no methods that are specific to RED objects.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIbytes_\fP
Set to "true" to enable ``byte-mode'' RED, where the size of arriving
packets affect the likelihood of marking (dropping) packets.
.IP \fIqueue-in-bytes_\fP
Set to "true" to measure the average queue size in bytes rather than
packets.
Enabling this option also causes \fIthresh_\fP and \fImaxthresh_\fP to
be automatically scaled by \fImean_pktsize_\fP (see below).
.IP \fIthresh_\fP
The minimum threshold for the average queue size in packets.
.IP \fImaxthresh_\fP
The maximum threshold for the average queue size in packets.
.IP \fImean_pktsize_\fP
A rough estimate of the average packet size in bytes.  Used in updating
the calculated average queue size after an idle period.
.IP \fIq_weight_\fP
The queue weight, used in the exponential-weighted moving average for
calculating the average queue size.
.IP \fIwait_\fP
Set to true to maintain an interval between dropped packets.
.IP \fIlinterm_\fP
As the average queue size varies between "thresh_" and "maxthresh_",
the packet dropping probability varies between 0 and "1/linterm".
.IP \fIsetbit_\fP
Set to "true" to mark packets by setting
the congestion indication bit in packet headers 
rather than drop packets.
.IP \fIdrop-tail_\fP
Set to true to use drop-tail rather than random-drop when the queue
overflows or the average queue size exceeds "maxthresh_".
For a further explanation of these variables, see [2].
.LP
.HD
State Variables
.RS
None of the state variables of the RED implementation are accessible.
.RE

.SH "CBQ OBJECTS"
CBQ objects are a subclass of Queue objects that implement
class-based queueing.
.IP "\fB$cbq insert $class\fP"
Insert traffic class
.I class
into the link-sharing structure associated with link object 
.I cbq.
.IP "\fB$cbq bind $cbqclass $id1 [$id2]\fP"
Cause packets containing flow id
.I $id1
(or those in the range
.I $id1
to
.I $id2
inclusive)
to be associated with the traffic class
.I $cbqclass.
.IP "\fB$cbq algorithm $alg"
Select the CBQ internal algorithm.
.I $alg
may be set to one of: "ancestor-only", "top-level", or "formal".
.LP
.HD

.SH "CBQ/WRR OBJECTS"
CBQ/WRR objects are a subclass of CBQ objects that implement
weighted round-robin scheduling among classes of the same
priority level.  In contrast, CBQ objects implement packet-by-packet
round-robin scheduling among classes of the same priority level.
.HD
Configuration Parameters \fP
.RS
.IP \fImaxpkt_\fP
The maximum size of a packet in bytes.
This is used only by CBQ/WRR objects in
computing maximum bandwidth allocations
for the weighted round-robin scheduler.

.SH "CBQCLASS OBJECTS"
CBQClass objects implement the traffic classes associated with CBQ objects. 
.IP "\fB$cbqclass setparams \fIparent okborrow allot maxidle prio level extradelay\fP"
Sets several of the configuration parameters for the CBQ traffic class (see below).
.IP "\fB$cbqclass parent [$cbqcl|none]"
specify the parent of this class in the link-sharing tree.
The parent may be specified as ``none'' to indicate this class is a root.
.IP "\fB$cbqclass newallot $a"
Change the link allocation of this class to the specified amount (in range
0.0 to 1.0).
Note that only the specified class is affected.
.IP "\fB$cbqclass install-queue $q\fP"
Install a Queue object into the compound CBQ or CBQ/WRR link structure.
When a CBQ object is initially created, it includes no internal
queue (only a packet classifier and scheduler).
.LP
.HD
Configuration Parameters \fP
.RS 
.IP \fBokborrow_\fP
is a boolean indicating the class is permitted to borrow bandwidth
from its parent.
.IP \fBallot_\fP
is the maximum fraction of link bandwidth allocated to the class
expressed as a real number between 0.0 and 1.0.
.IP \fBmaxidle_\fP
is the maximum amount of time a class may be required to have its
packets queued before they are permitted to be forwarded
.IP \fBpriority_\fP
is the class' priority level with respect to other classes.
This value may range from 0 to 10, and more than one class
may exist at the same priority.
Priority 0 is the highest priority.
.IP \fBlevel_\fP
is the level of this class in the link-sharing tree.
Leaf nodes in the tree are considered to be at level 1;
their parents are at level 2, etc.
.IP \fBextradelay_\fP
increase the delay experienced by a delayed class by the specified
time

.SH "QUEUEMONITOR Objects"
QueueMonitor Objects are used to monitor
queue statistics like average queue size etc.
[see TRACE AND MONITORING METHODS].
.IP "\fB$queuemonitor set-delay-samples \fIdelaySamp_\fP"
Set up the Samples object
.I delaySamp_
to record statistics about queue delays.
.I delaySamp_
is a handle to a Samples object 
i.e the Samples object should have already been created.
.IP "\fB$queuemonitor get-bytes-integrator\fP"
Returns an Integrator object
that can be used to find the integral of the queue size in bytes.
(see Integrator Objects section).
.IP "\fB$queuemonitor get-pkts-integrator \fP"
Returns an Integrator object
that can be used to find the integral of the queue size in packets.
(see Integrator Objects section).
.IP "\fB$queuemonitor get-delay-samples\fP"
Returns a Samples object
.I delaySamp_
to record statistics about queue delays
(see Samples Objects section).
.LP
There are no configuration parameters specific to this object.
.LP
.HD
State Variables
.LP
.RS
.IP \fIsize_\fP
Instantaneous queue size in bytes.
.IP \fIpkts_\fP
Instantaneous queue size in packets.
.IP \fIparrivals_\fP
Running total of packets that have arrived.
.IP \fIbarrivals_\fP
Running total of bytes contained in packets that have arrived.
.IP \fIpdepartures_\fP
Running total of packets that have departed.
.IP \fIbdepartures_\fP
Running total of bytes contained in packets that have departed.
.IP \fIpdrops_\fP
Total number of packets dropped.
.IP \fIbdrops_\fP
Total number of bytes dropped.
.IP \fIbytesInt_\fP
Integrator object that computes
the integral of the queue size in bytes. 
The
.I sum_
variable of this object has the running sum (integral)
of the queue size in bytes.
.IP \fIpktsInt_\fP
Integrator object that computes
the integral of the queue size in packets. 
The
.I sum_
variable of this object has the running sum (integral)
of the queue size in packets.
.RE

.SH "UNICAST ROUTING METHODS"
A dynamic unicast routing protocol
can be specified to run
on a subset of nodes in the topology.
Note that a dynamic routing protocol should
be generally used whenever 
a simulation is done
with network dynamics.
.IP "\fB$ns rtproto \fIproto node-list\fP"
Specifies the dynamic unicast routing protocol
.I proto 
to be run on the nodes specified by
.I node-list.
Currently
.I proto
can be one of
Static, Session, DV.
Static routing is the default.
Session implies
that the unicast routes
over the entire topology
are instantaneously recomputed
whenever a link goes up or down.
DV implies that a 
simple distance vector routing protocol
is to be simulated.
.I node-list
defaults to all the nodes in the topology.
.IP "\fB$ns compute-routes\fP"
Compute routes between all the nodes in the topology.
This can be used if static routing is done
and the routes have to be recomputed
as the state of a link has changed.
Note that Session routing (see 
.I rtproto 
method above)
will recompute routes automatically whenever
the state of any link in the topology changes.
.IP "\fB$ns get-routelogic\fP"
Returns an handle to 
a RouteLogic object that
has methods for route table lookup etc.

.SH "ROUTELOGIC OBJECTS"
.IP "\fB$routelogic lookup \fIsrcid destid\fP"
Returns the id of the node that is the next hop from
the node with id
.I srcid
to the node with id
.I destid.
.IP "\fB$routelogic dump \fInodeid\fP"
Dump the routing tables of all nodes
whose id is less than
.I nodeid.
Node ids are typically assigned to nodes
in ascending fashion starting from 0
by their order of creation.

.SH "RTOBJECT OBJECTS"
Every node that takes part in a dynamic
unicast routing protocol will have an instance
of rtObject
(see NODE OBJECTS section for the method
to get an handle to this object at a particular node).
Note that nodes will not have an instance of this
object if Session routing is done as a detailed
routing protocol is not being simulated in this case.
.IP "\fB$rtobject dump-routes \fIfileID\fP"
Dump the routing table to the output channel
specified by
.I fileID.
.I fileID
must be a file handle returned by the Tcl
.I open
command and it must have been opened for writing.
.IP "\fB$rtobject rtProto? \fIproto\fP"
Returns a handle to 
the routing protocol agent
specified by
.I proto
if it exists at that node.
Returns an empty string otherwise.
.IP "\fB$rtobject nextHop? \fIdestID\fP"
Returns the id of the node 
that is the next hop
to the destination specified by the node id,
.I destID.
.IP "\fB$rtobject rtpref? \fIdestID\fP"
.IP "\fB$rtobject metric? \fIdestID\fP"

.SH "MULTICAST ROUTING METHODS"
Multicast routing is enabled
by setting Simulator EnableMcast_ variable
to 1 at the beginning of the simulation.
Note that this variable must be set before
any node, link or agent objects are created
in the simulation.
Also links must have been created with
interface labels 
(see simplex-link and duplex-link methods in NS COMMANDS section).
.IP "\fB$ns mrtproto \fIproto node-list\fP"
Specifies the multicast routing protocol
.I proto 
to be run on the nodes specified by
.I node-list.
Currently
.I proto
can be one of
CtrMcast, DM, dynamicDM, pimDM.
.I node-list
defaults to all the nodes in the topology.
Returns an handle to a protocol-specific object
that has methods, configuration parameters
specific to that protocol.
Note that currently CtrMcastComp object
is returned if CtrMcast is used
but a null string is returned
if DM, dynamicDM or pimDM are used.

If proto is 'CtrMcast'
a Rendezvous Point (RP) rooted shared tree is built
for a multicast group.
The actual sending
of prune, join messages etc.
to set up state at the nodes is not simulated.
A centralized computation agent is used
to compute the fowarding trees and set up 
multicast forwarding state, (*,G) at the relevant nodes
as new receivers join a group.
If a sender to a group sends data less than
a certain threshold(?), 
packets are unicast to the RP.
Only when the data rate threshold is crossed,
multicast forwarding state 
is set up from the sender to the RP.
Methods are provided in the CtrMcastComp object
that is returned by mrtproto 
to switch to source-specific trees,
choose some nodes as candidate RPs etc.
Note that the above mechanisms reflect the
Protocol Independent Multicast - Sparse Mode (PIM-SM) [cite]
specifications.
When a node/link on a multicast distribution tree
goes down, the tree is instanteously recomputed.

If proto is 'DM'
DVMRP-like dense mode is simulated.
Parent-child lists are used
to reduce the number of links over which
the data packets are broadcast.
Prune messages are sent by nodes
to remove branches from the multicast forwarding tree
that do not lead to any group members.
This does not adapt to network changes.

If proto is 'dynamicDM'
DVMRP-like dense mode protocol that
adapts to network changes is simulated.
In addition to parent-child lists 
a downstream-member list per source is maintained
for every outgoing interface
and 'poison-reverse' information
(i.e. the information that a particular neighbouring node
uses me to reach a particular network)
is read from the routing tables of neighbouring nodes
(DVMRP runs its own unicast routing protocol
that exchanges this information).

If proto is 'pimDM'
Protocol Independent Multicast - Dense mode is simulated.
In this case the data packets are broadcast
over all the outgoing links except the incoming link.
Prune messages are sent by nodes to remove
the branches of the multicast forwarding tree
that do not lead to any group members.

.SH "CTRMCASTCOMP OBJECTS"
A handle to the CtrMcastComp object is returned
when the protocol is specified as 'CtrMcast'
in mrtproto.
.IP "\fB$ctrmcastcomp switch-treetype \fIgroup-addr\fP"
Switch from the Rendezvous Point rooted shared tree
to source-specific trees 
for the group specified by
.I group-addr.
Note that it's not possible to switch back
from source-specific trees to 
a shared tree for the group 
(on the lines of Protocol Independent Multicast - Sparse Mode [cite]).
.IP "\fB$ctrmcastcomp set_c_rp \fInode-list\fP"
Make all the nodes specified in
.I node-list
as candidate RPs.
All nodes are candidate RPs by default
and currently the node with the highest node id
serves as the RP for all multicast groups.
This is likely to change soon.
.IP "\fB$ctrmcastcomp set_c_bsr \fInode-priority-list\fP"
Make all the specified nodes as 
candidate bootstrap routers with 
the specified priorities as given in
.I node-priority-list.
.I node-priority-list
is a list of the form node:priority
where node is a node object handle
and priority is an integer that determines
the priority of the node in becoming the Bootstrap router.
.IP "\fB$ctrmcastcomp get_rp \fInode group\fP"
.IP "\fB$ctrmcastcomp get_bsr \fInode\fP"

.SH "DM OBJECTS"
DM Objects implement DVMRP style densemode multicast
where parent-child lists are used to reduce
the number of links over which 
initial data packets are broadcast.
There are no methods or state variables specific to this object.
.LP
Configuration parameters
PruneTimeout
Timeout value for the prune state at nodes.

.SH "AGENT OBJECTS"
.IP "\fB$agent port\fP"
Return the transport-level port of the agent.
Ports are used to identify agents within a node.
.IP "\fB$agent dst-addr\fP"
Return the address of the destination node this agent is connected to.
.IP "\fB$agent dst-port\fP"
Return the port at the destination node that this agent is connected to.
.IP "\fB$agent attach-source \fItype\fP"
Install a data source
of type
.I type
in this agent.
.I type
is one of FTP or bursty[???].
See the corresponding object methods
for information on configuration parameters.
Returns a handle to the source object.
.IP "\fB$agent attach-traffic \fItraffic-object\fP"
Attach
.I traffic-object
to this agent
.I traffic-object
is an instance of 
Traffic/Expoo, Traffic/Pareto or Traffic/Trace.
Traffic/Expoo generates traffic based on 
an Exponential On/Off distribution.
Traffic/Pareto generates traffic based on
a Pareto On/Off distribution.
Traffic/Trace generates traffic from a trace file.
The relevant configuration parameters for 
each of the above objects can be 
found in the TRAFFIC METHODS section.
.IP "\fB$agent connect\fI addr port\fP"
Connect this agent to the agent identified by the address
.I addr
and port
.I port.
This causes packets transmitted from this agent to contain the
address and port indicated, so that such packets are routed to
the intended agent.  The two agents must be compatible (e.g.,
a tcp-source/tcp-sink pair as opposed a cbr/tcp-sink pair).
Otherwise, the results of the simulation are unpredictable.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIdst_\fP
Address of destination that the agent is connected to. Currently 32
bits with the higher 24 bits the destination node ID and the
lower 8 bits being the port number.
.LP
There are no state variables specific to the generic agent class.
.RE

.SH "NULL OBJECTS"
Null objects are a subclass of agent objects that 
implement a traffic sink.
They inherit all of the generic agent object functionality.
There are no methods, configuration parameters or state variables
specific to this object.

.SH "LOSSMONITOR OBJECTS"
LossMonitor objects are a subclass of agent objects 
that implement a traffic sink which also maintains some 
statistics about the received data e.g.,
number of bytes received, number of packets lost etc.
They inherit all of the generic agent object functionality.
.IP "\fB$lossmonitor clear\fP"
Resets the expected sequence number to -1.
.LP
.HD
Configuration Parameters \fP
.LP
.RS
There are no configuration parameters specific to this object.
.RE
.HD
State Variables \fP
.LP
.RS
.IP \fInlost_\fP
Number of packets lost.
.IP \fInpkts_\fP
Number of packets received.
.IP \fIbytes_\fP
Number of bytes received.
.IP \fIlastPktTime_\fP
Time at which the last packet was received.
.IP \fIexpected_\fP
The expected sequence number of the next packet.
.RE

.SH "TCP OBJECTS"
TCP objects are a subclass of agent objects that implement the
BSD Tahoe TCP transport protocol.  They inherit all of the 
generic agent functionality.
.LP
.HD
Configuration Parameters \fP
.RS
.IP \fIwindow_\fP
The upper bound on the advertised window for the TCP connection.
.IP \fIwindowInit_\fP
The initial size of the congestion window on slow-start.
.IP \fIwindowOption_\fP
The algorithm to use for managing the congestion window.
.IP \fIwindowThresh_\fP
Gain constant to exponential averaging filter used to compute
.I awnd
(see below).
For investigations of different window-increase algorithms.
.IP \fIoverhead_\fP
The range of a uniform random variable used to delay each output
packet.  The idea is to insert random delays at the source
in order to avoid phase effects, when desired [4].  
This has only been implemented for the Tahoe ("tcp") version of tcp, not
for tcp-reno.  This is not intended to be a 
realistic model of CPU processing overhead.
.IP \fIecn_\fP
Set to true to use explicit congestion notification in addition
to packet drops to signal congestion.
.IP \fIpacketSize_\fP
The size in bytes to use for all packets from this source.
.IP \fItcpTick_\fP 
The TCP clock granularity for measuring roundtrip times.
.IP \fIbugFix_\fP
Set to true to remove a bug when multiple fast retransmits are allowed
for packets dropped in a single window of data.
.IP \fImaxburst_\fP
Set to zero to ignore.  Otherwise, the maximum number of packets that
the source can send in response to a single incoming ACK.
.IP \fIMWS\fP
The Maximum Window Size in packets for a TCP connection.  MWS determines
the size of an array in tcp-sink.cc.
The default for MWS is 1024 packets.
For Tahoe TCP, the "window" parameter, representing the receiver's
advertised window, should be less than MWS-1.  For Reno TCP, the
"window" parameter should be less than (MWS-1)/2.
(MWS is currently a defined constant, but we plan to change MWS
to a configuration parameter in a future release.)
.RE
.LP  
.HD 
State Variables
.RS
.LP
.IP \fIdupacks_\fP
Number of duplicate acks seen since any new data was acknowledged.
.IP \fIseqno_\fP
Current position in the sequence space (can move backwards).
.IP \fIack_\fP
Highest acknowledgment seen from receiver.
.IP \fIcwnd_\fP
Current value of the congestion window.
.IP \fIawnd_\fP
Current value of a low-pass filtered version of the congestion window.
For investigations of different window-increase algorithms.
.IP \fIssthresh_\fP
Current value of the slow-start threshold.
.IP \fIrtt_\fP
Round-trip time estimate.
.IP \fIsrtt_\fP
Smoothed round-trip time estimate.
.IP \fIrttvar_\fP
Round-trip time mean deviation estimate.
.IP \fIbackoff_\fP
Round-trip time exponential backoff constant.
.RE

.SH "TCP/RENO OBJECTS"
TCP/Reno objects are a subclass of TCP objects that implement the
Reno TCP transport protocol.
There are no methods, configuration parameters or state variables
specific to this object (?).
.RE

.SH "TCP/NEWRENO OBJECTS"
TCP/Newreno objects are a subclass of TCP objects that implement 
a modified version of the BSD Reno TCP transport protocol.
There are no methods state variables
specific to this object (?).
Configuration Parameters \fP
.LP
.RS
.IP \fInewreno_changes_\fP
.RE

.\" .SH "TCP/VEGAS OBJECTS"
.\" TCP/Vegas objects are a subclass of TCP objects that implement 
.\" a modified version of the Reno TCP transport protocol (?).
.\" There are no methods state variables
.\" specific to this object (?).
.\" Configuration Parameters \fP
.\" .LP
.\" .RS
.\" .IP \fIvegas_changes_\fP
.\" .RE

.SH "TCP/SACK1 OBJECTS"
TCP/Sack1 objects are a subclass of TCP objects that implement 
the BSD Reno TCP transport protocol with Selective
Acknowledgement Extensions.
They inherit all of the TCP object functionality (?).
There are no methods, configuration parameters or state variables
specific to this object (?).

.SH "TCP/FACK OBJECTS"
TCP/Fack objects are a subclass of TCP objects that implement 
the BSD Reno TCP transport protocol with Forward
Acknowledgement congestion control.
They inherit all of the TCP object functionality.
There are no methods or state variables specific to this object.
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIss-div4\fP
Overdamping algorithm. Divides ssthresh by 4 (instead of 2) 
if congestion is detected within 1/2 RTT of slow-start. (1=Enable, 0=Disable)
.IP \fIrampdown\fP
Rampdown data smoothing algorithm. Slowly reduces congestion window 
rather than instantly halving it. (1=Enable, 0=Disable) 
.RE

.SH "TCPSINK OBJECTS"
TCPSink objects are a subclass of agent objects that implement 
a receiver for TCP packets.
The simulator only implements "one-way" TCP connections, where the
TCP source sends data packets and the TCP sink sends ACK packets.
TCPSink objects inherit all of the generic agent functionality.
There are no methods or state variables specific to the TCPSink object.
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIpacketSize_\fP
The size in bytes to use for all acknowledgment packets.
.IP \fImaxSackBlocks_\fP
Should this go in TCPSink/Sack1?
.RE

.SH "TCPSINK/DELACK OBJECTS"
DelAck objects are a subclass of TCPSink that implement
a delayed-ACK receiver for TCP packets.
They inherit all of the TCPSink object functionality.
There are no methods or state variables specific to the DelAck object.
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIinterval_\fP
The amount of time to delay before generating an acknowledgment
for a single packet.  If another packet arrives before this
time expires, generate an acknowledgment immediately.
.RE

.SH "TCPSINK/SACK1 OBJECTS"
TCPSink/Sack1 objects are a subclass of TCPSink that implement
a SACK receiver for TCP packets.
They inherit all of the TCPSink object functionality.
There are no methods, configuration parameters or state variables
specific to this object.

.SH "TCPSINK/SACK1/DELACK OBJECTS"
TCPSink/Sack1/DelAck objects are a subclass of TCPSink/Sack1 that implement
a delayed-SACK receiver for TCP packets.
They inherit all of the TCPSink/Sack1 object functionality.
There are no methods or state variables specific to this object.
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIinterval_\fP
The amount of time to delay before generating an acknowledgment
for a single packet.  If another packet arrives before this
time expires, generate an acknowledgment immediately.
.RE

.SH "CONSTANT BIT-RATE OBJECTS"
CBR objects generate packets at a constant bit rate.
They inherit all of the generic agent functionality.
.IP "\fB$cbr start\fP"
Causes the source to start generating packets.
.IP "\fB$cbr stop\fP"
Causes the source to stop generating packets.
.LP
.HD
Configuration Parameters 
.LP
.RS
.IP \fIinterval_\fP
The amount of time to delay between packet transmission times.
.IP \fIpacketSize_\fP
The size in bytes to use for all packets from this source.
.IP \fIrandom_\fP
.RE

.SH "FTP SOURCE OBJECTS"
FTP source objects create data for a transport object to send
(e.g., TCP).
.IP "\fB$ftp start\fP"
Causes the source to start producing an unbounded amount of data.
.IP "\fB$ftp produce \fIn\fP"
Causes the source to produce exactly
.I n
packets instantaneously.
.RE
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fImaxpkts\fP
The maximum number of packets generated by the source.
.RE

.SH "TELNET SOURCE OBJECTS"
TO BE DONE

.SH "TRAFFIC OBJECTS"
Traffic objects create data for a transport protocol to send.
Currently traffic objects can be attached only to UDP transport.
A Traffic object is created by instantiating an object of class
Traffic/
.I type
where
.I type
is one of Expoo, Pareto, Trace.
Traffic/Expoo objects are for generating Exponential On/Off distributions.
Traffic/Pareto objects are for generating Pareto On/Off distributions.
Traffic/Trace objects are for generating traffic using a trace file.

.SH "TRAFFIC/EXPOO OBJECTS"
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIpacket-size\fP
The packet size in bytes.
.IP \fIburst-time\fP
Burst duration in seconds.
.IP \fIidle-time\fP
Idle time in seconds.
.IP \fIrate\fP
Peak rate in bytes per second.

.SH "TRAFFIC/PARETO OBJECTS"
.HD
Configuration Parameters \fP
.LP
.RS
.IP \fIpacket-size\fP
The packet size in bytes.
.IP \fIburst-time\fP
Average on time in seconds.
.IP \fIidle-time\fP
Average off time in seconds.
.IP \fIrate\fP
Peak rate in bytes per second.
.IP \fIshape\fP
Pareto shape parameter.

.SH "TRAFFIC/TRACE OBJECTS"
Traffic/Trace objects are used to generate traffic from a trace file.
.IP "\fB$trace attach-tracefile \fItfile\fP"
Attach the Tracefile object
.I tfile
to this trace.
The Tracefile object
specifies the trace file
from which the traffic data is to be read
(see TRACEFILE OBJECTS section).
.LP
There are no configuration parameters for this object.

.SH "TRACEFILE OBJECTS"
Tracefile objects are used to specify the 
trace file that is to be used 
for generating traffic (see TRAFFIC/TRACE OBJECTS section).
$tracefile is an instance of the Tracefile Object.
.IP "\fB$tracefile filename \fItrace-input\fP"
Set the filename from which
the traffic trace data is to be read to
.I trace-input.
.LP
There are no configuration parameters for this object. (Tracefile format?)

.SH "TRACE AND MONITORING METHODS"
Trace objects are used to generate event level capture logs typically
to an output file. 
Throughout this section $ns 
refers to a Simulator/MultiSim object.

.IP "\fB$ns create-trace \fItype fileID node1 node2\fP"
Create a Trace object of type
.I type
and attach the filehandle
.I fileID
to it to monitor the
queues between nodes
.I node1
and
.I node2.
.I type
can be one of
Enque, Deque, Drop.
Enque monitors packet arrival at a queue.
Deque monitors packet departure at a queue.
Drop monitors packet drops at a queue.
.I fileID
must be a file handle returned by the Tcl
.I open
command and it must have been opened for writing.
Returns a handle to the trace object.

.IP "\fB$ns drop-trace \fInode1 node2 trace\fP"
Remove trace object attached to
the link between nodes
.I node1
and
.I node2
with 
.I trace
as the object handle.

.IP "\fB$ns trace-queue \fInode1 node2 fileID\fP"
Enable Enque, Deque and Drop
tracing on the link between
.I node1
and
.I node2.

.IP "\fB$ns trace-all \fIfileID\fP"
Enable Enque, Deque, Drop Tracing 
on all the links in the topology
created after this method is invoked.
Also enables the tracing of network dynamics.
.I fileID
must be a file handle returned by the Tcl
.I open
command and it must have been opened for writing.

.IP "\fB$ns monitor-queue \fInode1 node2\fP"
Arrange for queue length of link
between nodes
.I node1
and
.I node2
to be tracked.
Returns QueueMonitor object that can be queried
to learn average queue size etc.
[see QueueMonitor Objects section]

.IP "\fB$ns flush-trace\fP"
Flush the output channels attached to all the trace objects.

.IP "\fB$link trace-dynamics \fIns fileID\fP"
Trace the dynamics of this link
and write the output to
.I fileID
filehandle.
.I ns
is an instance of the Simulator or MultiSim object
that was created to invoke the simulation.

.LP
The tracefile format is backward compatible
with the output files in the
ns version 1 simulator
so that ns-1 post-processing
scripts can still be used.
Trace records of traffic for link objects with Enque, Deque or Drop
Tracing have the following form:
.LP
.RS
.nf
    <code> <time> <hsrc> <hdst> <packet>
.fi
.RE
.LP
where
.LP
.RS
.nf
<code> := [hd+-] h=hop d=drop +=enque -=deque
<time> := simulation time in seconds
<hsrc> := first node address of hop/queuing link
<hdst> := second node address of hop/queuing link
<packet> :=  <type> <size> <flags> <flowID> <src.sport> <dst.dport> <seq> <pktID>
<type> := tcp|telnet|cbr|ack etc.
<size> := packet size in bytes
<flags> := [CP]  C=congestion, P=priority
<flowID> := flow identifier field as defined for IPv6
<src.sport> := transport address (src=node,sport=agent)
<dst.sport> := transport address (dst=node,dport=agent)
<seq> := packet sequence number
<pktID> := unique identifer for every new packet
.fi

Only those agents interested in
providing sequencing will generate
sequence numbers and hence
this field may not be 
useful for packets generated by some agents.

.LP
For links that use RED gateways,
there are additional trace records as follows:
.LP 
.RS 
.nf
    <code> <time> <value> 
.fi
.RE 
.LP 
where
.LP 
.RS 
.nf
<code> := [Qap] Q=queue size, a=average queue size, 
	p=packet dropping probability 
<time> := simulation time in seconds
<value> := value
.fi 
.RE

.LP
Trace records for link dynamics are of the form:
.LP
.RS
.nf
    <code> <time> <state> <src> <dst>
.fi
.RE
.LP
where
.LP
.RS
.nf
<code> := [v]
<time> := simulation time in seconds
<state> := [link-up | link-down]
<src> := first node address of link
<dst> := second node address of link
.fi
.RE

.SH "INTEGRATOR Objects"
Integrator Objects support the approximate computation
of continuous integrals using discrete sums.
The running sum(integral) is computed as:
sum_ +=  [lasty_ * (x - lastx_)]
where (x, y) is the last element entered and (lastx_, lasty_)
was the element previous to that added to the sum.
lastx_ and lasty_ are updated as new elements 
are added.
The first sample point defaults to (0,0)
that can be changed by changing the values of (lastx_,lasty_).
.IP "\fB$integrator newpoint \fIx y\fP"
Add the point (x,y) to the sum.
Note that it does not make sense for x to be less than lastx_.
.LP
There are no configuration parameters specific to this object.
.LP
.HD
State Variables
.LP
.RS
.IP \fIlastx_\fP
x-coordinate of the last sample point.
.IP \fIlasty_\fP
y-coordinate of the last sample point.
.IP \fIsum_\fP
Running sum (i.e. the integral) of the sample points.

.SH "SAMPLES Objects"
Samples Objects support the computation of 
mean and variance statistics for a given sample.
.IP "\fB$samples mean\fP"
Returns mean of the sample.
.IP "\fB$samples variance\fP"
Returns variance of the sample.
.IP "\fB$samples cnt\fP"
Returns a count of the sample points considered.
.IP "\fB$samples reset\fP"
Reset the Samples object to monitor a fresh set of samples.
.LP
There are no configuration parameters or state variables specific to
this object. 

.SH BUILTINS
Because
.I OTcl
is a full-fledged programming language, it is easy to build
high-level simulation constructs from the ns primitives.
Several library routines have been built in this way, and
are embedded into the ns interpreter
as methods of the Simulator class.
Throughout this section
$ns represents a Simulator object.

.IP "\fB$ns create-connection \fIsrcType srcNode dstType dstNode class\fP
Create a source agent of type
.I srcType
at node
.I srcNode
and connect it to a destination agent of type
.I dstType
at node
.I dstNode.
Also, connect the destination agent to the source agent.
The traffic class of both agents is set to
.I class.
This method returns the source agent.

.SH EXAMPLE
.nf
    set ns [new Simulator]

    #
    # Create two nodes 
    #
    set n0 [$ns node]
    set n1 [$ns node]

    #
    # Create a trace and arrange for all the trace events of the 
    # links subsequently created to be dumped to "out.tr"
    #
    set f [open out.tr w]
    $ns trace-all $f

    #
    # Connect the two nodes with a 1.5Mb link with a transmission
    # delay of 10ms using FIFO drop-tail queuing
    #
    $ns duplex-link $n0 $n1 1.5Mb 10ms DropTail

    #
    # Set up BSD Tahoe TCP connections in opposite directions.
    #
    set tcp_src1 [new Agent/TCP]
    set tcp_snk1 [new Agent/TCPSink]
    set tcp_src2 [new Agent/TCP]
    set tcp_snk2 [new Agent/TCPSink]
    $ns attach-agent $n0 $tcp_src1
    $ns attach-agent $n1 $tcp_snk1
    $ns attach-agent $n1 $tcp_src2
    $ns attach-agent $n0 $tcp_snk2
    $ns connect $tcp_src1 $tcp_snk1
    $ns connect $tcp_src2 $tcp_snk2

    #
    # Create ftp sources at the each node
    #
    set ftp1 [$tcp_src1 attach-source FTP]
    set ftp2 [$tcp_src2 attach-source FTP]

    #
    # Start up the first ftp at the time 0 and
    # the second ftp staggered 1 second later
    #

    $ns at 0.0 "$ftp1 start"
    $ns at 1.0 "$ftp2 start"

    #
    # run the simulation for 10 simulated seconds
    #
    $ns at 10.0 "exit 0"
    $ns run
.fi

.SH DEBUGGING 
To enable debugging when building ns from source:
.nf
    % ./configure --enable-debug
    % make 
.fi
.LP
For more details about ns debugging
please see
<http://www-mash.cs.berkeley.edu/ns/ns-debugging.html>.

.SH DIFFERENCES FROM NS-1
In general, more complex objects in ns-1 have been broken down
into simpler components for greater flexibility
and composability.
Details of differences between ns-1 and ns-2
can be found at 
<http://www-mash.cs.berkeley.edu/ns/ns.html>.

.SH HISTORY
Work on the LBL Network Simulator began in May 1990 with modifications to
S. Keshav's (keshav@research.att.com) REAL network
simulator, which he developed for his Ph.D. work at U.C. Berkeley.
In Summer 1991, the simulation description language
was revamped, and later, the NEST threads model was
replaced with an event driven framework and
an efficient scheduler.  Among other contributions, 
Sugih Jamin (jamin@usc.edu)
contributed the calendar-queue based scheduling code
to this version of the program, which was known as 
.I tcpsim.
In December 1994, McCanne ported tcpsim
to C++ and replaced the yacc-based simulation description
language with a Tcl interface, and added preliminary
multicast support.  Also at this time, the name changed from 
.I tcpsim
to the more generic
.I ns.
Throughout, Floyd has made modifications to
the TCP code and added additional source models for her
investigations into RED gateways, resource management,
class-based queuing, explicit congestion notification,
and traffic phase effects.  Many of the papers discussing these
issues are available through URL http://www-nrg.ee.lbl.gov/.

.SH "SEE ALSO"
Tcl(1),
tclsh(1),
nam(1),
otclsh

.IP \fB[1]\fP
S. Keshav, ``REAL: A Network Simulator''.  UCB CS Tech Report 88/472,
December 1988.  See
http://minnie.cs.adfa.oz.au/REAL/index.html
for more information.
.IP \fB[2]\fP
Floyd, S. and Jacobson, V.  Random Early Detection gateways for
Congestion Avoidance.  IEEE/ACM Transactions on Networking,
Vol. 1, No. 4.  August 1993.  pp. 397-413.  Available from
http://www-nrg.ee.lbl.gov/floyd/red.html.
.IP \fB[3]\fP
Floyd, S.  Simulator Tests.  July 1995.
URL ftp://ftp.ee.lbl.gov/papers/simtests.ps.Z.
.IP \fB[4]\fP
Floyd, S., and Jacobson, V.
On Traffic Phase Effects in Packet-Switched Gateways.
Internetworking: Research and Experience, V.3 N.3, September 1992.
pp. 115-156.
.IP \fB[5]\fP
Floyd, S., and Jacobson, V.
Link-sharing and Resource Management Models for Packet Networks.
IEEE/ACM Transactions on Networking, Vol. 3 No. 4, August 1995. 
pp. 365-386.
.IP \fB[6]\fP
Floyd, S.,
Notes of Class-Based Queueing: Setting Parameters.
URL ftp://ftp.ee.lbl.gov/papers/ params.ps.Z.  September 1995.
.IP \fB[7]\fP
Fall, K., and Floyd, S.  Comparisons of Tahoe, Reno, and Sack TCP.
December 1995.  URL ftp:// ftp.ee.lbl.gov/papers/sacks.ps.Z.
.IP \fB[8]\fP
David Wetherall and Christopher J. Linblad.
Extending Tcl for Dynamic Object-Oriented Programming.
In Proceedings of the USENIX Tcl/Tk Workshop, Toronto, Ontario, USENIX.
July, 1995.
At <http://www.tns.lcs.mit.edu/publications/tcltk95.djw.html>.
.IP \fB[9]\fP
M. Shreedhar and G. Varghese. Efficient Fair Queueing Using Deficit
Round Robin. In Proc. of SIGCOMM, pp. 231-242, 1995.
.LP
Work on ns is on-going.
Information about the most recent version is available
at 
<http://www-mash.cs.berkeley.edu/ns/ns.html>.
.LP
Mailing lists for ns are available,
send mail to ns-developers-request@mash.cs.berkeley.edu
or ns-users-request@mash.cs.berkeley.edu
to join.

.SH AUTHORS
Steven McCanne (mccanne@ee.lbl.gov), University of California, Berkeley
and Lawrence Berkeley National Laboratory, Berkeley, CA, and
Sally Floyd (floyd@ee.lbl.gov)
Lawrence Berkeley National Laboratory, Berkeley, CA.
.SH BUGS

Not all of the functionality supported in ns-1 has been ported to ns-2.

This manual page is incomplete.


