\documentclass{article}

\usepackage{times}
\usepackage[T1]{fontenc}

\PassOptionsToPackage{draft}{MyPreamble}
\usepackage[widen-page,skrunch-figures]{MyPreamble}
\usepackage{nsDoc}

\begin{document}

\title{\nsTcl\ internals documentation}
\author{%
  Kevin Fall \tup{kfall@ee.lbl.gov}\\
  Kannan Varadhan \tup{kannan@catarina.usc.edu}}
\date{\today}

\def\c#1{\ensuremath{C_{#1}}}
\def\d#1{\ensuremath{D_{#1}}}

% \maketitle

\section{Session-level Packet Distribution}
\label{sec:session}

This section describes the internals of the Session-level Packet Distribution
implementation in \ns.
The section is in two parts:
the first part is an overview of 
a minimal Session configuration,
and a ``complete'' description of the configuration parameters 
of a Session.
The second part describes the architecture, internals, and the code path
of the Session-level Packet distribution.

\subsection{Configuration}
\label{sec:session-config}

Each Session (i.e., a multicast tree) must be configured strictly in
this order:
 
1. creating(obtaining) the session source,
2. assigning the destination address,
3. creating the session helper, 
4. attaching to session source, and
5. the session members joining the group.


\subsubsection{Basic Configuration}
\label{sec:basic-config}
\begin{program}
        set ns [new SessionSim]          \; preamble initialization;
        set node [$ns node]              \; source and receiver to reside on this node;
        set group [$ns allocaddr]        \; multicast group for this session;

        set src [new Agent/CBR]
        $src  set dst_ $group            \; configure the source;
        $ns attach-agent $node $src

        $ns create-session $node $src \; creating the session helper and attaching to the source

	set rcvr [new Agent/NULL]        \; configure the receiver
	$ns attach-agent $node $rcvr
	$ns at 0.0 "$node join-group $rcvr $group" \; joining the session

	$ns at 0.1 "$src start"          \; start the source

\end{program}

\subsubsection{Inserting a Loss Module}
\label{sec:loss-config}
\paragraph{Creating a Loss Module}
Before we can insert a loss module in between a source-receiver pair,
we have to create the loss module.  Basically,
a loss module compares two values to decide whether to drop a packet.
The first value is obtained every time when the loss module receives 
a packet from a random variable.  The second value
is fixed and configured when the loss module is created.

The following code gives an example to create a uniform 
0.1 loss rate.

\begin{program}
set loss_random_variable [new RandomVariable/Uniform] \; creating a uniform distribution random variable
$loss_random_variable set min_ 0
$loss_random_variable set max_ 100

set loss_module [new ErrorModel]                    \; creating an error module
$loss_module drop-target [new Agent/Null]           \; set target for dropped packets
$loss_module set rate_ 10             \; set error rate to 0.1, 1/(10-0)
$loss_module ranvar $loss_random_variable \; attaching the random variable to the loss module
\end{program}

Several random variable distributions are available.  Please refer to
tcl/ex/ranvar.tcl.

\paragraph{Inserting a Loss Module}

One loss module is required for each pair source-receiver pair. If it is
intended to insert a loss module for a receiver, keep a handle to the 
loss module when created.  Loss modules can only be inserted after the
corresponding receivers finish joining the group.

\begin{program}
set sessionhelper [$ns create-session $node $src] \; keep a handle to the loss module
$ns at 0.1 "$sessionhelper insert-loss $loss_module $rcvr" \; insert the loss module
\end{program}

Please note that packets dropped for a particular receiver should also 
be dropped for its downstream receivers.  We are currently
working on solving this problem error dependency problem.  Before 
we complete the implementation, please carefully calculate and 
place your loss modules.

\subsection{Architecture}
\label{sec:session-arch}
The purpose of Session-level packet distribution is to
speed up simulations and reduce memory consumption while 
maintaining reasonable accuracy(if no queuing involved).  The first
bottleneck observed is the memory consumption by heavy-weight
links and nodes.  Therefore, in SessionSim (Simulator for Session-level
packet distribution), we keep only minimal amount of 
states for links and nodes, and connect the higher level source and 
receiver applications with appropriate delay and loss modules.  When
a connection is a multicast group, we attach a replicator 
to the source application, so the replicator replicates packets
to all loss or delay modules attached to the receiver applications.

In short, almost the entire network layer(routing and queuing)
is abstract out.  Packets in SessionSim do not get routed.  
They only follow the established Session.

\subsection{Internals}
In this section, we explain the internals of Session-level Packet 
Distribution.  The implementation is split into two parts:
\begin{list}{}{}
\item  Linkage of objects to make a Session in OTcl 
\item  Packet forwarding activities are executed by C++ methods.  
\end{list}

\subsubsection{Object Linkage}
\label{sec:session-objlink}

\begin{list}{}{}
\item  Simplified links and nodes.
\item  Replicator
\item  Delay and loss modules
\end{list}

\paragraph{Nodes and Links}
\label{sec:session-nodenlink}
A link only contains the values of
its bandwidth and delay, and a node contains only its id and port number
for next agent.

\begin{program}
SessionSim instproc simplex-link { n1 n2 bw delay type } {
    $self instvar link_ delay_
    set sid [$n1 id]
    set did [$n2 id]

    set link_($sid:$did) [expr [string trimright $bw Mb] * 1000000]
    set delay_($sid:$did) [expr [string trimright $delay ms] * 0.001]
}

SessionNode instproc init {} {
    $self instvar id_ np_
    set id_ [Node getid]
    set np_ 0
}
\end{program}

\paragraph{Replicator}
One replicator is required per source.  While the source is configured,
a replicator (session helper) need to be attached to the source.  By
calling create-session{}, a replicator is:
1. created,
2. attached to the source application
3. kept in a SessionSim instance variable session_ array with 
its source and destination addresses as the index.

Note that the destination of source agent must be set before
calling create-session{}.

\begin{program}
SessionSim instproc create-session { node agent } {
    $self instvar session_

    set nid [$node id]                           \; get source address
    set dst [$agent set dst_]                    \; get destination address
    set session_($nid:$dst) [new Classifier/Replicator/Demuxer]  \; creating the replicator
    $agent target $session_($nid:$dst)           \; attach the replicator to the source
    return $session_($nid:$dst)                  \; keep the replicator in the SessionSim instance variable session_ array
}
\end{program}

\paragraph{Delay and Loss Modules}

%% PH: not sure \ref is the right syntax
At least one delay module is required per receiver. See section \ref{sec:loss-config} for inserting a loss module for a receiver.
When a receiver joins a group, the join-group{} method goes through
all replicators (session helpers) maintained in session_.  If the destination index matches the group address the receiver intends to join, 
then the following actions are performed.

1. a new slot of the replicator (session helper) is created and assigned to the receiver.
2. accumulated bandwidth and delay between the source and receiver are obtained by SessionSim instance procedure get-bw{} and get-delay{}.
3. a constant random variable is created and assigned with the
accumulative delay.
4. a delay module is created and assigned with the constant random 
variable and the accumulative bandwidth.
5. the delay module in inserted into the replicator slot in
front of the receiver.

\begin{program}
SessionSim instproc join-group { agent group } {
    $self instvar session_

    foreach index [array names session_] {
	set pair [split $index :]
	if {[lindex $pair 1] == $group} {
	    # Note: must insert the chain of loss, delay, 
	    # and destination agent in this order:

	    #1. insert destination agent into session replicator
	    $session_($index) insert $agent


	    #2. find accumulative bandwidth and delay
	    set src [lindex $pair 0]
	    set dst [[$agent set node_] id]
	    set accu_bw [$self get-bw $dst $src]
	    set delay [$self get-delay $dst $src]

	    #3. set up a constant delay random variable
	    set random_variable [new RandomVariable/Constant]
	    $random_variable set avg_ $delay

	    #4. set up the delay module
	    set delay_module [new DelayModel]
	    $delay_module bandwidth $accu_bw
    	    $delay_module ranvar $random_variable

	    #4. insert the delay module in front of the dest agent
	    $session_($index) insert-module $delay_module $agent
	}
    }
}
\end{program}


\subsubsection{Packet Forwarding}
Packet forwarding activities are executed in C++.  A source application 
generates a packet and forwards to its target which must be a replicator 
(session helper).  The replicator copies the packet and forwards 
to targets in the active slots which are either delay modules or loss modules. If loss modules, a decision is made whether to drop the packet.
If yes, the packet is forwarded to the loss modules drop target.  If not,
the loss module forwards it to its target which must be a delay module.
The delay module will forward the packet with a delay to its target which
must be a receiver application.

%% PH: not sure this will come out right
\begin{program}
                    / Loss module - Delay module - Receiver 1
Source - Replicator --------------- Delay module - Receiver 2
    (Session Helper)\ Loss module - Delay module - Receiver 3

\end{program}

\end{document}

### Local Variables:
### mode: latex
### comment-column: 60
### backup-by-copying-when-linked: t
### file-precious-flag: nil
### End:
