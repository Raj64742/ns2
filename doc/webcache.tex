\chapter{Web cache as an application}
\label{chap:webcache}

All applications described above are ``virtual'' applications, in the sense
that they do not actually transfer their own data in the simulator; all 
that matter is the \emph{size} and the \emph{time} when data are transferred.
Sometimes we may want applications to transfer their own data in simulations.
One such example is web caching. Here we want HTTP servers to send HTTP 
headers of every page to caches and clients. These headers contain 
page modification time information and other caching directives, which are 
important for some cache consistency algorithms.

The following describes the APIs to transport application data over TCP, 
as well as the internals of the web caching applications.

\section{Transmitting application data over TCP}
\label{sec:webcache-tcpapp}

As indicated in section \ref{sec:upcalls}, transmission of application data
can be implemented via agent upcalls. Assuming we are using TCP agents, 
all data are delivered in sequence, which means we can view the TCP 
connection as a FIFO pipe. Because ns doesn't support actual data passing, 
we have to emulate that behavior. First, we need to provide buffer 
for application data at the sender. Then we count the bytes receives at the 
receiver. When the receiver has got all bytes of current data transmission,
it then get the data directly from the sender. Class Application/TcpApp is 
used to implement this functionality.

An TcpApp object contains a pointer to a transport agent, presumably either
a FullTcp or a SimpleTcp. 
\footnote{A SimpleTcp agent is used solely for web caching simulations. It 
is actually an UDP agent. It has neither error recovery nor flow/congestion
control. It doesn't do packet segmentation. Assuming loss-free and all
packets are delivered in order, SimpleTcp agent simplifies the trace files 
and hence aids the debugging of application protocols, which, in our case, 
is the web cache consistency protocol.}
(Currently TcpApp doesn't support asymmetric TCP agents, i.e., sender is
separated from receiver). It provides the following OTcl interfaces:

\begin{itemize}
\item \code{connect}: Connecting another TcpApp to this one. This
  connection is bi-directional, i.e., only one call to \code{connect} is 
  needed, and data can be sent in either direction. 
\item \code{send}: It takes two arguments: \code{(nbytes, str)}.
  \code{nbytes} is the ``nominal'' size of application data. \code{str} 
p  is application data in string form.
\end{itemize}

In order to send application data in binary form, TcpApp provides a 
virtual C++ method \code{send(int nbytes, int dsize, const char *data)}.
In fact, this is the method used to implement the OTcl method \code{send}.
Because it's difficult to deal with binary data in Tcl, no OTcl interface
is provided to handle binary data. \code{nbytes} is the number of bytes 
to be transmitted, \code{dsize} is the actual size of the array \code{data}.

TcpApp provides a C++ virtual method \code{process_data(int size, char*data)}
to handle the received data. The default handling is to treat the data 
as a tcl script and evaluate the script. But it's easy to derive a class
to provide other types of handling.

Here is an example of using Application/TcpApp. A similar example is 
\code{Test/TcpApp-2node} in \ns/tcl/test/test-suite-webcache.tcl.
First, we create FullTcp agents and connect them:

\begin{program}
        set tcp1 [new Agent/TCP/FullTcp]
        set tcp2 [new Agent/TCP/FullTcp]
        # {\cf Set TCP parameters here, e.g., window_, iss_, \ldots}

        $ns attach-agent $n1 $tcp1
        $ns attach-agent $n2 $tcp2
        $ns connect $tcp1 $tcp2
        $tcp2 listen
\end{program}

Then we Create TcpApps and connect them:

\begin{program}
        set app1 [new Application/TcpApp $tcp1]
        set app2 [new Application/TcpApp $tcp2]
        $app1 connect $app2
\end{program}

Now we let \code{$app1} %$
be sender and \code{$app2} %$ 
be receiver:

\begin{program}
        $ns at 1.0 "$app1 send 100 \bs"$app2 app-recv 100\bs""
\end{program} %$

Where \code{recv} is defined as:

\begin{program}
        Application/TcpApp instproc app-recv { size } {
                global ns
                puts "[$ns now] app2 receives data $size from app1"
        }
\end{program}


\section{Overview of web cache classes}
\label{sec:webcache-class}

There are three major classes related to web cache, as it is in the
real world: client (browser), server, and cache. Because they share a
common feature, i.e., the HTTP protocol, they are derived from the
same base class \code{Http} (Name of OTcl class, it's called
\code{HttpApp} in C++). For the following reasons, it's not a real
Application.  First, an HTTP object (i.e., client/cache/server) may
want to maintain multiple concurrent HTTP connections, but an
Application contains only one \code{agent_}.  Also, an HTTP object
needs to transmit real data (e.g., HTTP header) and that's provided by
TcpApp instead of any Agent. Therefore, we choose to use a standalone
class derived from TclObject for common features of all HTTP objects,
which are managing HTTP connections and a set of pages.  In the rest
of the section, we'll discuss these functionalities of Http. In the
next three sections, we'll in turn describe HTTP client, cache and
server.

\subsection{Managing HTTP connections}
\label{sec:webcache-connection}

Every HTTP connection is embodied as a TcpApp
object. Http maintains a hash of TcpApp objects, which are all of 
its active connections. It assumes that to any other Http, it 
has only one HTTP connection. It also allows dynamic establishment and 
teardown of connections. Only OTcl interface is provided for establishing,
tearing down a connection and sending data through a connection.

\paragraph{OTcl methods}

\begin{alist}
id & return the id of the Http object, which is the id of the node the object
is attached to. \\

get-cnc \tup{client} & return the TCP agent associated with \$client (Http object).\\

is-connected \tup{server} & return 0 if not connected to \$server, 1 otherwise.\\

send \tup{client} \tup{bytes} \tup{callback} & send \$bytes of data to 
\$client. When it's done, execute \$callback (a OTcl command). \\

connect \tup{client} \tup{TCP} & associate a TCP agent with \$client (Http object). That agent will be used to send packets \emph{to} \$client. \\

disconnect \tup{client} & delete the association of a TCP agent with \$client.
Note that neither the TCP agent nor \$client is not deleted, only the 
association is deleted.\\
\end{alist}

\paragraph{Configuration parameter}

By default, Http objects use Agent/SimpleTcp as transport agents
(section \ref{sec:webcache-tcpapp}). They can also use Agent/FullTcp
agents, which allows Http objects to operate in a lossy network.
Class variable code{TRANSPORT\_} is used for this purpose. E.g.,
\code{Http set TRANSPORT\_ FullTcp} tells all Http objects use
FullTcp agents.

This configuration should be done \emph{before} simulation starts, and 
it should not change during simulation, because FullTcp agents do not 
inter-operate with SimpleTcp agents.

\subsection{Managing web pages}
\label{sec:webcache-page}

Http also provides OTcl interfaces to manage a set of pages. The 
real management of pages are handled by class \code{PagePool} and its
subclasses. Because different HTTP objects have different requirements
for page management, we allow different PagePool subclasses to be attached
to different subclasses of Http class. Meanwhile, we export
a common set of PagePool interfaces to OTcl through
Http. For example, a browser may use a PagePool only to generate a 
request stream, so its PagePool only needs to contain a list of URLs. But
a cache may want to store page size, last modification time of every page 
instead of a list of URLs. However, this separation is not clearcut in 
the current implementation. 

Page URLs are represented in the form of:
\code{\tup{ServerName}:\tup{SequenceNumber}}
where the {\tt ServerName} is the name of OTcl object, and 
every page in every server should have a unique {\tt SequenceNumber}. 
Page contents are ignored. Instead, every page contains several 
\emph{attributes}, which are represented in OTcl as a list of the following 
(\tup{name} \tup{value}) pairs: ``modtime \tup{val}'' (page 
modification time), ``size \tup{val}'' (page size), and ``age \tup{val}''\}
The ordering of these pairs is not significant.

Following is a list of related OTcl methods.

\begin{alist}
set-pagepool \tup{pagepool} & set page pool \\

enter-page \tup{pageid} \tup{attributes} & add a page with id \$pageid
into pool. \$attributes is the attributes of \$pageid, as described above. \\

get-page \tup{pageid} & return page attributes in the format described 
above. \\

get-modtime \tup{pageid} & return the last modification time of the page 
\$pageid. \\

exist-page \tup{pageid} & return 0 if \$pageid doesn't exist in this 
Http object, 1 otherwise. \\

get-size \tup{pageid} & return the size of \$pageid. \\

get-cachetime \tup{pageid} & return the time when page \$pageid is entered
into the cache. \\
\end{alist}

\subsection{Debugging}
\label{sec:webcache-debug}

HttpApp also provides two debugging methods. \code{log} registers a file 
handle as the trace file for all HttpApp-specific traces. Its trace format 
is described in section \ref{webcache-trace}. \code{evTrace} logs a 
particular event into trace file. It concatenates
time and the id of the HttpApp to the given string, and writes it out. 
They can be found in \ns/webcache/http.cc.


\section{Web client}
\label{sec:webcache-client}

Class Http/Client models behavior of a simple web browser. It
generates a sequence of page requests, where request interval and page 
IDs are randomized. It's a pure OTcl class inherited from Http. 
Next we'll walk through its functionalities and usage.

\paragraph{Creating a client}

First of all, we create a client and connect it to a cache and a web server.
Currently a client is only allowed to connect to a single cache, but it's 
allowed to connect to multiple servers. Note that this has to be called 
\emph{AFTER} the simulation starts (i.e., after \code{$ns run} %$
is called).
This remains true for all of the following methods and code examples of 
Http and its derived classes, unless explicitly said.

\begin{program}
        # Assuming $server is a configured Http/Server. 
        set client [new Http/Client $ns $node] \; client resides on this node;
        $client connect $server \; connecting client to server;
\end{program} %$

\paragraph{Configuring request generation}

For every request, Http/Client uses PagePool to generate a random page
ID, and use a random variable to generate intervals between two 
consecutive requests:
\footnote{Some PagePool,
e.g., PagePool/Math, has only one page and therefore it always returns the
same page. Some other PagePool, e.g. PagePool/Trace, has multiple pages 
and needs a random variable to pick out a random page.} 

\begin{program}
        $client set-page-generator $pgp \; attach a configured PagePool;
        $client set-interval-generator $ranvar \; attach a random variable;
\end{program}

Here we assume that PagePools of Http/Client share the same set of pages
as PagePools of the server. Usually we simplify our simulation by letting
all clients and servers share the same PagePool, i.e., they have the same
set of pages. When there are multiple servers, or servers' PagePools 
are separated from those of clients', care must be taken to make sure that 
every client sees the same set of pages as the servers to which they are
attached.

\paragraph{Starting}

After the above setup, starting requests is very simple:

\begin{program}
        $client start-session $cache $server \; assuming $cache is a configured Http/Cache;
\end{program}

\paragraph{OTcl interfaces}
Following is a list of its OTcl methods (in addition to those
inherited from Http). This is not a complete list. More details can be
found in \ns/tcl/webcache/http-agent.tcl.

\begin{alist}
send-request \tup{server} \tup{type} \tup{pageid} \tup{args} & 
send a request of page \$pageid and type \$type to \$server. The only 
request type allowed for a client is GET. \$args has a format identical
to that of \$attributes described in \code{Http::enter-page}. \\

start-session \tup{cache} \tup{server} & start sending requests of a 
random page to \$server via \$cache. \\

start \tup{cache} \tup{server} & before sending requests, populate
\$cache with all pages in the client's PagePool. This method is useful 
when assuming infinite-sized caches and we want to observe behaviors 
of cache consistency algorithms in steady state. \\

set-page-generator \tup{pagepool} & attach a PagePool to generate 
random page IDs.\\

set-interval-generator \tup{ranvar} & attach a random variable to generate
random request intervals.\\
\end{alist}


\section{Web server}
\label{seccom:webcache-server}

Class Http/Server models behavior of a HTTP server. Its
configuration is very simple. All that a user needs to do is to create 
a server, attach a PagePool and wait:

\begin{program}
        set server [new Http/Server $ns $node] \; attach \$server to \$node;
        $server set-page-generator $pgp \; attach a page pool;
\end{program}

An Http/Server object waits for incoming requests after simulation starts.
Usually clients and caches initiates connection to an Http/Server. But 
it still has its own \code{connect} method, which allows an Http/Server 
object to actively connect to a certain cache (or client). Sometimes this
is useful, as explained in Test/TLC1::set-groups\{\} in 
\ns/tcl/test/test-suite-webcache.tcl.

An Http/Server object accepts two types of requests: GET and IMS.  GET
request models normal client requests. For every GET request, it
returns the attributes of the requested page.  IMS request models
If-Modified-Since used by TTL algorithms for cache consistency. For
every IMS (If-Modified-Since) request, it compares the page
modification time given in the request and that of the page in its
PagePool. If the time indicated in the request is older, it sends back
a response with very small size, otherwise it returns all of the page 
attributes with response size equal the real page size.


\section{Web cache}
\label{sec:webcache-cache}

Currently 6 types of web caches are implemented, including 
the base class Http/Cache. Its five derived subclasses 
implement 5 types of cache consistency algorithms: Plain old TTL, 
adaptive TTL, Omniscient TTL, Hierarchical multicast invalidation, 
and hierarchical multicast invalidation plus direct request.

In the following we'll only describe the base class Http/Cache, because 
all the subclasses involves discussion of cache consistency algorithms 
and it does not seem to be appropriate here.

\subsection{Http/Cache}
\label{sec:webcache-cache-base}

Class Http/Cache models behavior of a simple HTTP cache with infinite 
size. It doesn't contain removal algorithm, nor consistency algorithm. 
It is not intended to be used by itself. Rather, it is meant to be a 
base class for experimenting with various cache consistency algorithms and
other cache algorithms. 

\paragraph{Creation and startup}

Creating an Http/Cache requires the same set of parameters as
Http/Client and Http/Server. After creation, a cache needs to connect 
to a certain server. Note that this creation can also be done dynamically,
when a request comes in and the cache finds that it's not connected to 
the server. However, we do not model this behavior in current code.
Following code is an example:

\begin{program}
        set cache [new HttpCache $ns $node] \; attach cache to \$node;
        $cache connect $server \; connect to \$server;
\end{program}

Like Http/Server, an Http/Cache object waits for requests (and packets
from server) after it's initialized as above. When hierarchical
caching is used, the following can be used to create the hierarchy:

\begin{program}
        $cache set-parent $parent \; set parent cache;
\end{program}

Currently all TTL and multicast invalidation caches support hierarchical
caching. However, only the two multicast invalidation caches allows 
multiple cache hierarchies to inter-operate.

\paragraph{OTcl methods}

Although Http/Cache is a SplitObject, all of its methods are in OTcl. 
Most of them are used to process an incoming request. Their relations can
be illustrated with the flowchart below, followed by explainations:

\begin{figure}[h]
  \begin{center}
    \includegraphics{cache-flowchart}
    \caption{Handling of incoming request in Http/Cache}
    \label{fig:webcache-handle-request}
  \end{center}
\end{figure}

\begin{alist}
get-request \tup{client} \tup{type} \tup{pageid} & 
The entry point of processing any request. It checks if the requested 
page \$pageid exists in the cache's page pool, then call either 
\code{cache-hit} or \code{cache-miss}. \\

cache-miss \tup{client} \tup{type} \tup{pageid} & 
This cache doesn't have the page. Send a request to server (or parent 
cache) to refetch the page if it hasn't already done so. Register 
\$client in a list so that when the cache gets the page, it'll forward
the page to all clients who have requested the page. \\

cache-hit \tup{client} \tup{type} \tup{pageid} &
Checks the validatity of the cached page. If it's valid, send \$client
the cached page, otherwise refetch the page. \\ 

is-consistent \tup{client} \tup{type} \tup{pageid} & 
Returns 1 if \$pageid is valid. This is intended to be overridden by 
subclasses. \\

refetch \tup{client} \tup{type} \tup{pageid} & 
Refetch an invalid page from server. This is intended to be overridden 
by subclasses. \\
\end{alist}


\section{Putting together: a simple example}
\label{sec:webcache-example}

We have seen all the pieces, now we present a script which provides a
complete view of all pieces together. First, we build topology and 
other usual initializations:

\begin{program}
        set ns [new Simulator]

        # Create topology/routing
        set node(c) [$ns node] 
        set node(e) [$ns node]
        set node(s) [$ns node]
        $ns duplex-link $node(s) $node(e) 1.5Mb 50ms DropTail
        $ns duplex-link $node(e) $node(c) 10Mb 2ms DropTail 
        $ns rtproto Session
\end{program}

Next we create the Http objects:

\begin{program}
        # HTTP logs
        set log [open "http.log" w]

        # Create page pool as a central page generator. Use PagePool/Math
        set pgp [new PagePool/Math]
        set tmp [new RandomVariable/Constant] \;# Page size generator;
        $tmp set val_ 1024  \;# average page size;
        $pgp ranvar-size $tmp
        set tmp [new RandomVariable/Exponential] \;# Page age generator;
        $tmp set avg_ 5 \;# average page age;
        $pgp ranvar-age $tmp

        set server [new Http/Server $ns $node(s)] \;# Create a server and link it to the central page pool;
        $server set-page-generator $pgp
        $server log $log

        set cache [new Http/Cache $ns $node(e)] \;# Create a cache;
        $cache log $log

        set client [new Http/Client $ns $node(c)] \;# Create a client;
        set tmp [new RandomVariable/Exponential] \;# Poisson process as request sequence;
        $tmp set avg_ 5 \;# average request interval;
        $client set-interval-generator $tmp
        $client set-page-generator $pgp
        $client log $log

        set startTime 1 \;# simulation start time;
        set finishTime 50 \;# simulation end time;
        $ns at $startTime "start-connection"
        $ns at $finishTime "finish"
\end{program} %$

Then we define a procedure which will be called after simulation
starts.  The procedure will setup connections among all Http objects.
\begin{program}
        proc start-connection {} {
                global ns server cache client
                $client connect $cache
                $cache connect $server
                $client start-session $cache $server
        }
\end{program} %$

At the end, the usual closing:
\begin{program}
        proc finish {} {
                global ns log
                $ns flush-trace
                flush $log
                close $log
                exit 0
        }
        $ns run
\end{program}

This script is also available at \ns/tcl/ex/simple-webcache.tcl. 
Examining its output \code{http.log}, one will find that the result of 
the absense cache consistency algorithm results in a lot of stale hits. 
This can be easily remedied by replacing ``new Http/Cache'' line with:
\code{set cache [new Http/Cache/TTL $ns $node(e)]}. For more complicated
cache consistency algorithm examples, see 
\ns/tcl/test/test-suite-webcache.tcl.

\section{Http trace format}
\label{sec:webcache-trace}

The trace file of Http agents are constructed in a similar way as the
SRM trace files. It consists of multiple entries, each of which
occupies one line.  The format of each entry is:

\begin{tabular}[h]{c|c|c}
  Time & ObjectID & Object Values
\end{tabular}

There are three types of objects: client ({\bf C}), cache ({\bf E})
and server ({\bf S}). Following is a complete enumeration of all possible 
events and value types associated with these three types of objects.

\begin{center}
  \begin{tabular}[h]{c|c|l}
    \emph{Object Type} & \emph{Event Type} & \emph{Values} \\ \hline
    E & HIT & \tup{Prefix} \\
    E & MISS & \tup{Prefix} z \tup{RequestSize} \\
    E & IMS & \tup{Prefix} z \tup{Size} t \tup{CacheEntryTime} \\
    E & REF & p \tup{PageID} s \tup{ServerID} z \tup{Size} \\
    E & UPD & p \tup{PageID} m \tup{LastModifiedTime} z \tup{PageSize} \\
    &     & s \tup{ServerID} \\ 
    E & GUPD & z \tup{PageSize} \\
    E & SINV & p \tup{PageID} m \tup{LastModTime} z \tup{PageSize} \\
    E & GINV & p \tup{PageID} m \tup{LastModTime} \\
    E & SPF & p \tup{PageID} c \tup{DestCache} \\
    E & RPF & p \tup{PageID} c \tup{SrcCache} \\
    E & ENT & p \tup{PageID} m \tup{LastModifiedTime} z \tup{PageSize} \\
    &     & s \tup{ServerID} \\ \hline
    C & GET & p \tup{PageID} s \tup{PageServerID} z \tup{RequestSize}\\
    C & STA & p \tup{PageID} s \tup{OrigServerID} l \tup{StaleTime}\\
    C & RCV & p \tup{PageID} s \tup{PageServerID} l \tup{ResponseTime} z \tup{PageSize}\\ \hline
    S & INV & p \tup{PageID} m \tup{LastModifiedTime} z \tup{Size} \\
    S & UPD & p \tup{PageID} m \tup{LastModifiedTime} z \tup{Size} \\
    S & SND & p \tup{PageID} m \tup{LastModifiedTime} z \tup{PageSize} \\
    &     & t \tup{Requesttype} \\
  \end{tabular}
\end{center}

\tup{Prefix} is the information common to all trace entries. It includes:

\begin{center}
  \begin{tabular}[h]{c|c|c}
    p \tup{PageID} & c \tup{RequestClientID} & s \tup{PageServerID}
  \end{tabular}
\end{center}

\emph{Short Explaination of event operations}: 

\begin{center}
  \begin{tabular}[h]{c|c|l}
    \emph{Object Type} & \emph{Event Type} & \emph{Explaination} \\ \hline
    E & HIT & Cache hit. PageSererID is the id of the ``owner'' of the page. \\
    E & MISS & Cache miss. In this case the cache will send a request to the
    server to fetch the page. \\
    E & IMS & If-Modified-Since. Used by TTL procotols to validate an expired 
    page. \\
    E & REF & Page refetch. Used by invalidation protocols to refetch an 
    invalidated page. \\
    E & UPD & Page update. Used by invalidation protocols to ``push'' updates\\
      & & from parent cache to children caches. \\
    E & SINV & Send invalidation. \\
    E & GINV & Get invalidation. \\
    E & SPF & Send a pro forma \\
    E & RPF & Receive a pro forma \\
    E & ENT & Enter a page into local page cache. \\ 
    \hline
    C & GET & Client sends a request for a page. \\
    C & STA & Client gets a stale hit. OrigModTime is the modification time \\
    & & in the web server, CurrModTime is the local page's modification time.\\
    C & RCV & Client receives a page. \\
    \hline
    S & SND & Server send a response. \\
    S & UPD & Server pushes a page update to its ``primary cache''. Used by
    invalidation protocol only. \\
    S & INV & Server sends an invalidation message. Used by invalidation 
    protocol only. \\
  \end{tabular}
\end{center}


\endinput

% Local Variables:
% TeX-master: "everything"
% LocalWords:
% End:
