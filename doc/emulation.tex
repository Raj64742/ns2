\chapter{Emulation}
\label{sec:emulation}

This chapter describes the {\em emulation} facility
of \ns.
Emulation refers to the ability to introduce the
simulator into a live network.
Special objects within the simulator are capable
of introducing live traffic into the simulator and
injecting traffic from the simulator into the
live network.

\section{Introduction}

The emulation facility can be subdivided into
two modes:
\begin{enumerate}
\item {\sf opaque mode} -- live data treated as opaque data packets
\item {\sf protocol mode} -- live data may interpreted/generated by simulator
\end{enumerate}
In opaque mode, the simulator
treats network data as uninterpreted packets.
In particular, real-world protocol fields
are not directly manipulated by the simulator.
In opaque mode, live data packets may be dropped, delayed, re-ordered, or
duplicated, but because no protocol processing is performed,
protocol-specific traffic manipulation scenarios (e.g. ``drop the TCP segment
containing a retransmission of sequence number 23045'') may not be performed.
In protocol mode, the simulator is able to interpret and/or generate
live network traffic containing arbitrary field assignments.
{\bf To date (Mar 1998), only Opaque Mode is currently implemented}.

The interface between the simulator and live network is provided by
a collection of objects including {\em tap agents} and {\em network objects}.
Tap agents embed live network data into simulated packets and
vice-versa.
Network objects are installed in tap agents and provide an entrypoint
for the sending and receipt of live data.
Both objects are described in the following sections.

When using the emulation mode, a special version of the system
scheduler is used: the {\tt RealTime} scheduler.
This scheduler uses the same underlying structure as the
standard calendar-queue based scheduler, but ties the execution of
events to real-time.
It is described below.

\section{Real-Time Scheduler}

In progress.

\section{Tap Agents}

The class {\tt TapAgent} is a simple class derived from the base
{\tt Agent} class.
As such, it is able to generate simulator packets containing
arbitrarily-assigned values within the \ns common header.
The tap agent handles the setting of the common header packet
size field and the type field.  
It uses the packet type {\tt PT\_LIVE} for packets injected
into the simulator.
Each tap agent can have at most one associated network object, although
more than one tap agent may be instantiated on a single simulator node.

\paragraph{Configuration}
Tap agents are able to send and receive packets to/from an
associated {\tt Network} object.
Assuming a network object {\tt \$netobj} refers to a network
object, a tap agent is configured using the {\tt network} method:
\begin{verbatim}
        set a0 [new Agent/Tap]
	$a0 network $netobj
	$a0 set fid_ 26
	$a0 set prio_ 2
	$ns connect $a0 $a1
\end{verbatim}
Note that the configuration of the flow ID and priority are
handled through the {\tt Agent} base class.
The purpose of setting the flow id field in the common header
is to label packets belonging to particular flows of live data.
Such packets can be differentially treated with respect
to drops, reorderings, etc.
The {\tt connect} method instructs agent {\tt \$a0} to send
its live traffic to the {\tt \$a1} agent via the current
route through the simulated topology.

\section{Network Objects}

Network objects provide access to a live network.
There are several forms of network objects, depending on the
protocol layer specified for access to the underlying network,
in addition to the facilities provided by the host operating system.
Use of some network objects requires special access
privileges where noted.
Generally, network objects provide an entrypoint into the live
network at a particular protocol layer (e.g. link, raw IP, UDP, etc)
and with a particular access mode (read-only, write-only, or read-write).
Some network objects provide specialized facilities such as filtering
or promiscuous access (i.e. the pcap/bpf network object)
or group membership (i.e. UDP/IP multicast).
The C++ class {\tt Network} is provided as a base class from
which specific network objects are derived.
Three network objects are currently supported: pcap/bpf, raw IP,
and UDP/IP.
Each are described below.

\subsection{Pcap/BPF Network Objects}

These objects provide an extended interface to the LBNL packet capture
library (libpcap).
(See {\tt ftp://ftp.ee.lbl.gov/libpcap.tar.Z} for more info).
This library provides the ability to capture link-layer frames
in a promiscuous fashion from network interface drivers
(i.e. a copy is made for those programs making use of libpcap).
It also provides the ability to read and write packet trace
files in the ``tcpdump'' format.
The extended interface provided by \ns also allows for writing
frames out to the network interface driver, provided the driver
itself allows this action.
Use of the library to capture or create live traffic may be protected;
one generally requires at least read access to the system's packet filter
facility which may need to be arranged through a system administrator.

The packet capture library works on several UNIX-based platforms.
It is optimized for use with the Berkeley Packet Filter (BPF)~\cite{BPF},
and provides a filter compiler for the BPF pseudomachine machine code.
On most systems supporting it,
a kernel-resident BPF implementation the filter code, and 
applies the resulting pattern matching instructions to received frames.
Those frames matching the patterns are received through the BPF machinery;
those not matching the pattern are otherwise unaffected.
BPF also supports sending link-layer frames.
This is generally not suggested, as an entire properly-formatted frame
must be created prior to handing it off to BPF.
This may be problematic with respect to assigning proper link-layer headers
for next-hop destinations.
It is generally preferable to use the raw IP network object for sending
IP packets, as the system's routing function will be used to determine
proper link-layer encapsulating headers.

\paragraph{Configuration}
Pcap network objects may be configured as either associated with a
live network or with a trace file.
If associated with a live network, the particular network interface
to be used may be specified, as well as an optional promiscuous flag.
As with all network objects, they may be opened for reading or writing.
Here is an example:
\begin{verbatim}
     set me [exec hostname]
     set pf1 [new Network/Pcap/Live]
     $pf1 set promisc_ true
     set intf [$pf1 open readonly]
     puts "pf1 configured on interface $intf"
     set filt "(ip src host foobar) and (not ether broadcast)"
     set nbytes [$pf1 filter $filt]
     puts "filter compiled to $nbytes bytes"
     puts "drops: [$pf1 pdrops], pkts: [$pf1 pkts]"
\end{verbatim}
This example first determines the name of the local system which
will be used in constructing a BPF/libpcap filter predicate.
The {\tt new Network/Pcap/Live} call creates an instance of the
pcap network object for capturing live traffic.
The {\tt promisc\_} flag tells the packet filter whether it should
configure the undelying interface in promiscuous mode (if it is supported).
The {\tt open} call activates the packet filter, and may be specified
as {\tt readonly}, {\tt writeonly}, or {\tt readwrite}.
It returns the name of the network interface the filter is associated
with.
The {\tt open} call takes an optional extra parameter (not illustrated)
indicating the name of the interface to use in cases where a particular
interface should be used on a multi-homed host.
The {\tt filter} method is used to create a BPF-compatible packet
filter program which is loaded into the underlying BPF machinery.
The {\tt filter} method returns the number of bytes used by the
filter predicate. 
The {\tt pdrops} and {\tt pkts} methods are available for statistics
collection.
They report the number of packets dropped by the filter due to 
buffer exhaustion and the
total number of packets that arrived at the filter, respectively
({\em not} the number of packets accepted by the filter).

\subsection{IP Network Objects}



\endinput
