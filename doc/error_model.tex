%
% personal commentary:
%        DRAFT DRAFT DRAFT
%        - GNGUYEN
%
\chapter{Error Model}
\label{chap:error_model}

This chapter describes the implementation and configuration of error
models, which introduces packet losses into a simulation. 

\section{Implementation}

The procedures and functions described in this section can be found in
\nsf{errmodel.\{cc, h\}}.

Error model simulates link-level errors or loss by either marking the
packet's error flag or dumping the packet to a drop target.  In
simulations, errors can be generated from a simple model such as the
packet error rate, or from more complicated statistical and empirical models.
To support a wide variety of models, the unit of error can be specified
in term of packet, bits, or time-based.

The \code{ErrorModel} class is derived from the \code{Connector} base
class.  As the result, it inherits some methods for hooking up objects
such as \code{target} and \code{drop-target}.  If the drop target
exists, it will received corrupted packets from \code{ErrorModel}.
Otherwise, \code{ErrorModel} just marks the \code{error_} flag of the
packet's common header, thereby, allowing agents to handle the loss.
The \code{ErrorModel} also defines additional Tcl method \code{unit} to
specify the unit of error and \code{ranvar} to specify the random
variable for generating errors.  If not specified, the unit of error
will be in packets, and the random variable will be uniform distributed
from 0 to 1.  Below is a simple example of creating an error model with
the packet error rate of 1 percent (0.01):
\begin{program}
        # create a loss_module and set its packet error rate to 1 percent
        set loss_module [new ErrorModel]
        \$loss_module set rate_ 0.01

        # {\cf optional:  set the unit and random variable}
        \$loss_module unit pkt            \; error unit: packets (the default);
        \$loss_module ranvar [new RandomVariable/Uniform]

        # {\cf set target for dropped packets}
        \$loss_module drop-target [new Agent/Null]
\end{program}

In C++, the \code{ErrorModel} contains both the mechanism and policy for
dropping packets.  The packet dropping mechanism is handled by the
\code{recv} method, and packet corrupting policy is handled by the
\code{corrupt} method.
\begin{program}
        enum ErrorUnit \{ EU_PKT=0, EU_BIT, EU_TIME \};

        class ErrorModel : public Connector \{
        public:
                ErrorModel();
                void recv(Packet*, Handler*);
                virtual int corrupt(Packet*);
                inline double rate() \{ return rate_; \}
        protected:
                int command(int argc, const char*const* argv);
                ErrorUnit eu_;          \* error unit in pkt, bit, or time */
                RandomVariable* ranvar_;
                double rate_;
        \};
\end{program}
The \code{ErrorModel} only implements a simple policy based on a single
error rate, either in packets of bits.  More sophisticated dropping
policy can be implemented in C++ by deriving from \code{ErrorModel} and
redefining its \code{corrupt} method.

{\bf To be completed.}

\section{Configuration}

The previous section talked about error model, in this section we
discuss how to use error models in ns. 

To use an error model, it has to be inserted into a SimpleLink
object. Because a SimpleLink is a composite object (Chapter
\ref{chap:links}), an error model can
be inserted to many places. Currently we provide the following methods
to insert an error module into three different places. 

\begin{itemize}
\item Insert an error module in a SimpleLink BEFORE the queue module. 
  This is provided by the following two OTcl methods: 

  \begin{alist}
    SimpleLink::errormodule args & When an error model is given
    as a parameter, it inserts the error module into the simple link,
    right after the queue module, and set the drop-target of the error
    model to be the drop trace object of the simple link. Note that
    this requires the following configuration order: \code{\$ns
    namtrace-all} followed by link configurations, followed by error
    model insertion. When no argument is given, it returns the current
    error model in the link, if there's any. This method is defined in
    \ns/tcl/lib/ns-link.tcl \\

    Simulator::lossmodel \tup{em} \tup{src} \tup{dst} & Call
    SimpleLink::errormodule to insert the given error module into the
    simple link (src, dst). It's simply a wrapper for the above
    method. This method is defined in \ns/tcl/lib/ns-lib.tcl. 
  \end{alist}
  
\item Insert an error module in a SimpleLink AFTER the queue but
  BEFORE the delay link.
  This is provided by the following two methods:

  \begin{alist}
    SimpleLink::insert-linkloss args & This method's behavior
    is identical to that of \code{SimpleLink::errormodule}, except
    that it inserts an error module immediately after the queue
    object. It's defined in \ns/tcl/lib/ns-link.tcl \\

    Simulator::link-lossmodel \tup{em} \tup{src} \tup{dst} &
    This is a wrapper for \code{SimpleLink::insert-linkloss}. It's
    defined in \ns/tcl/lib/ns-lib.tcl 
  \end{alist}
  
  The nam traces generated by error models inserted using these two
  methods do not require special treatment and can be visualized using
  an older version of nam. 

\item Insert an error module in a Link AFTER the delay link module. 
  This can be done by \code{Link::install-error}. 
  Currently this API doesn't produce any trace. It only serves as a
  placeholder for possible future extensions. 
\end{itemize}


% Local Variables:
% TeX-master: "everything"
% LocalWords:
% End:
