\documentclass{article}

%\usepackage{times}
%\usepackage[T1]{fontenc}

\PassOptionsToPackage{draft}{MyPreamble}
\usepackage[widen-page,skrunch-figures]{MyPreamble}
\usepackage{nsDoc}

\begin{document}

\title{\nsTcl\ internals documentation}
\author{%
  Kevin Fall \tup{kfall@ee.lbl.gov}\\
  Kannan Varadhan \tup{kannan@catarina.usc.edu}}
\date{\today}

\def\c#1{\ensuremath{C_{#1}}}
\def\d#1{\ensuremath{D_{#1}}}

% \maketitle

\section{Agent/SRM}
\label{sec:agent/srm}

This section describes the internals of the SRM implementation in \ns.
The section is in three parts:
the first part is an overview of a minimal SRM configuration,
and a ``complete'' description of the comfiguation parameters 
of the base SRM agent.
The second part describes the architecture, internals, and the code path
of the base SRM agent.
The last part of the section is a description of the extensions
for other types of SRM agents that have been attempted to date.

\subsection{Configuration}
\label{sec:srm-config}

Running an SRM simulation requires
creating and configuring the agent,
attaching an application-level data source (a traffic generator), and
starting the agent and the traffic generator.

\subsubsection{Trivial Configuration}

\paragraph{Creating the Agent}
\begin{program}
set ns [new Simulator]                  \; preamble initialisation;
$ns enableMcast                         \\
set node [$ns node]                     \; agent to reside on this node;
set group [$ns allocaddr]               \; multicast group for this agent;
\\
{\bfseries set srm [new Agent/SRM]}     \\
$srm  set dst_ $group                   \; configure the SRM agent;
{\bfseries $ns attach-agent $node $srm} \\
\\
$srm  set fid_ 1                        \; optional configuration;
$srm  log [open srmStats.tr w]          \; log statistics in this file;
$srm  trace [open srmEvents.tr w]       \; trace events for this agent;
\end{program}
The key steps in configuring a virgin SRM agent are to assign
its multicast group, and attach it to a node.

Other useful configuration parameters are
to assign a separate flow id to traffic originating from this agent,
to open a log file for statistics, and
a trace file for trace data%
\footnote{%
Note that the trace data can also be used
to gather certain kinds of trace data.
We will illustrate this later.}.

The file
\fcnref{\|tcl/mcast/srm-nam.tcl|}{../ns-2/srm-nam.tcl}{Agent/SRM::send}
contains definitions to further separate control traffic
originating from all SRM agents by type.
Each type is allocated a separate flowID.
This is useful for analysis of traffic traces, or
for visualisation in nam.
To do this, the user must source \|srm-nam.tcl| before
creating any SRM agents.
The traffic is separated into session messages (flowid = 40),
requests (flowid = 41), and repair messages (flowid = 42).
The base flowid can be changed by setting global variable \|ctrlFid|
to one less than the desired flowid before sourcing \|srm-nam.tcl|.

\paragraph{Application Data Handling}
The agent does not generate any application data on its own;
instead, the simulation user can connect any traffic generation
module to any SRM agent to generate data.
The following code demonstrates how the traffic generation
modules can be attached to an SRM agent:
\begin{program}
  set packetSize 210                                                     \\
  set exp0 [new Traffic/Expoo]          \; configure traffic generator;
  $exp0 set packet-size $packetSize                                      \\
  $exp0 set burst-time 500ms                                             \\
  $exp0 set idle-time 500ms                                              \\
  $exp0 set rate 100k                                                    \\
\\
  set s0 [new Agent/CBR/UDP]    \; attach traffic generator to application;
  $s0 set fid_ 0                                                         \\
  $s0 attach-traffic $exp0                                               \\
\\
  {\bfseries $srm(0) traffic-source $s0} \; attach application to SRM agent;
  {\bfseries $srm(0) set packetSize_ $packetSize} \; to generate repair packets of appropriate size;
\end{program}
The instproc \texttt{\textbf{traffic-source}} specifies the application agent
that will produce data for the SRM agent.
The user can attach any agent;
the only distinguishing criteria is that the destination address must be zero.
The SRM agent will add the SRM headers, 
set the destination address to the multicast group, and
deliver the packet to its target.

The SRM agent does not generate its own data;
it does not also keep track of the data sent,
except to record the sequence numbers of messages received
in the event that it has to do error recovery.
Since the agent has no actual record of past data,
it needs to know what packet size to use for each repair message.
Hence, the instance variable \|packetSize\_| specifies the size
of repair messages generated by the agent.

\paragraph{Starting the Agent and Traffic Generator}
The user can separately start the agent and the traffic generator.
\begin{program}
{\bfseries \fcnref{$srm start}{../ns-2/srm.tcl}{Agent/SRM::start}} \\
{\bfseries \fcnref{$srm start-source}{../ns-2/srm.tcl}{Agent/SRM::start-source}}
\end{program}
At \|start|, the agent joins the multicast group, and 
starts generating session messages.
The \|start-source| triggers the traffic generator to start sending
data.

\subsubsection{Other Configuration Parameters}

In addition to the above parameters,
the SRM agent supports additional configuration variables.
Each of the variables described in this subsection is
both a class variable and an instance variable.
Changing the class variable changes the default value
for all agents that are created subsequently.
Changing the instance variable of a particular agent
only affects the values used by that agent.
For example,
\begin{program}
  \>Agent/SRM set D1_ 2.0     \; Changes the class variable;
  \>$srm set D1_ 2.0          \; Changes D1_ for the $srm object only;
\end{program}

The default request and repair timer parameters \cite{Floy95:Reliable}
for each SRM agent are:
\begin{program}
Agent/SRM set C1_       2.0             \; request parameters;
Agent/SRM set C2_       2.0             \\
Agent/SRM set D1_       1.0             \; repair parameters;
Agent/SRM set D2_       1.0             \\
\end{program}
It is thus possible to trivially obtain two flavours of SRM agents
based on whether the agents use probabilistic or deterministic
suppression by using the following definitions:
\begin{program}
Class Agent/SRM/Deterministic -superclass Agent/SRM     \\
Agent/SRM/Deterministic set C2_ 0.0                     \\
Agent/SRM/Deterministic set D2_ 0.0                     \\
                                                        \\
Class Agent/SRM/Probabilistic -superclass Agent/SRM     \\
Agent/SRM/Probabilistic set C1_ 0.0                     \\
Agent/SRM/Probabilistic set D1_ 0.0                     \\
\end{program}

Timer related functions are handled by separate objects
belonging to the class  SRM.
Timers are required for loss recovery and sending periodic session messages.
There are loss recovery objects to send request and repair messages.
The agent creates a separate request or repair object to handle each loss.
In contrast, the agent only creates one session object to send
periodic session messages.
The default classes the express each of these functions are:
\begin{program}
Agent/SRM set requestFunction_  "SRM/request"           \\
Agent/SRM set repairFunction_   "SRM/repair"            \\
Agent/SRM set sessionFunction_  "SRM/session"           \\
\\
Agent/SRM set requestBackoffLimit_      5   \; parameter to requestFunction_;
Agent/SRM set sessionDelay_             1.0 \; parameter to sessionFunction_;
\end{program}
The last two lines are specific parameters used by the request 
and session objects.
The \href{following section}{Section}{sec:architecture}
describes the implementation of theses objects in greater detail.

\subsubsection{Statistics}
Each agent tracks two sets of statistics:
statistics in response to data losses only,
and overall statistics for each request/repair.

\paragraph{Statistics in Response to Data Losses}
The statistics in response to data losses
measures the duplicate requests (and repairs),
and the average request (and repair) delay.
The algorithm used is as documented by Floyd \etal
\cite{Floy95:Reliable}.
In this algorithm,
each new request (or repair) starts a new request (or repair) period.
During the request (or repair) period, the agent measures
the number of first round duplicate requests (or repairs)
until the round terminates either due to receiving a request (or
repair), or due to the agent sending one.
These statistics are used by the adaptive timer algorithms;
we will describe our implementation of these algorithms in the following
subsections.
The following code illustrates how the user can simple retrieve the
current values in an agent:
\begin{program}
  set statsList [$srm array get statistics_]                \\
  array set statsArray [$srm array get statistics_]             \\
\end{program}
The first form simply returns a list of key-value pairs.
The second form loads the current values into the \|statsArray|;
The keys for each element of the array are
\|dup-req|, \|ave-dup-req|, \|req-delay|, \|ave-req-delay|,
\|dup-rep|, \|ave-dup-rep|, \|rep-delay|, and \|ave-rep-delay|.

\paragraph{Overall Statistics}
In addition, each error recovery and session object keeps track of
times and statistics.
In particular, each object records its
\|startTime|, \|serviceTime|, \|distance|, as are relevant to that object;
startTime is the time that this object was created,
serviceTime is the time for this object to complete its task, and the
distance is the one-way time to reach the remote peer.

For request objects, startTime is the time a packet loss is detected,
serviceTime is the time to finally receive that packet,
and distance is the distance to the original sender of the packet.
For repair objects, startTime is the time that a request for
retransmission is received, serviceTime is the time send a repair,
and the distance is the distance to the original requester.
For both types of objects, the serviceTime is normalised by the
distance.
``serviceTime'' and ``distance'' are not relevant to session objects.

Each object also maintains statistics particular to that type of object.
Request objects track the number of duplicate requests and repairs received,
the number of requests sent, and the number of times this object
had to backoff before finally receiving the data.
Repair objects track the number of duplicate requests and repairs,
as well as whether or not this object for this agent sent the repair.
Session objects simply record the number of session messages sent.

The values of the timers and the statistics for each object are written
to the log file every time an object completes the error recovery function
it was tasked to do.
The format of this trace file is:
\begin{program}
  \tup{prefix} \tup{id} \tup{times} \tup{stats} \\[1em]
\< {\itshape where} \\
\< \tup{prefix} is \>\> \tup{time} n \tup{node id} m \tup{msg id} r \tup{round} \\
\>\>\tup{msg id} is expressed as \tup{source id:sequence number}\\
\< \tup{id} is \>\> type \tup{of object} \\
\< \tup{times} is \>\> list of key-value pairs of startTime, serviceTime, distance \\
\< \tup{stats} is \>\> list of key-value pairs of per object statistics \\
\>\>\|dupRQST|, \|dupREPR|, \|#sent|, \|backoff|  \`for request objects \\
\>\>\|dupRQST|, \|dupREPR|, \|#sent|  \`for repair objects \\
\>\>\|#sent| \`for session objects \\
\end{program}
The following sample output illustrates the output file format:
\begin{verbatim}
 3.6274 n 0 m <1:1> r 1 type repair serviceTime 0.500222 startTime 3.5853553333333332 distance 0.0105 #sent 1 dupREPR 0 dupRQST 0
 3.6417 n 1 m <1:1> r 2 type request serviceTime 2.66406 startTime 3.5542666666666665 distance 0.0105 backoff 1 #sent 1 dupREPR 0 dupRQST 0
 3.6876 n 2 m <1:1> r 2 type request serviceTime 1.33406 startTime 3.5685333333333333 distance 0.021 backoff 1 #sent 0 dupREPR 0 dupRQST 0
 3.7349 n 3 m <1:1> r 2 type request serviceTime 0.876812 startTime 3.5828000000000002 distance 0.032 backoff 1 #sent 0 dupREPR 0 dupRQST 0
 3.7793 n 5 m <1:1> r 2 type request serviceTime 0.669063 startTime 3.5970666666666671 distance 0.042 backoff 1 #sent 0 dupREPR 0 dupRQST 0
 3.7808 n 4 m <1:1> r 2 type request serviceTime 0.661192 startTime 3.5970666666666671 distance 0.0425 backoff 1 #sent 0 dupREPR 0 dupRQST 0
\end{verbatim}

\paragraph{Miscellaneous Information}
Finally, the user can use the following methods to gather
additional information about the agent:
\begin{list}{\textbullet}{}
\item
  \fcnref{\proc[]{groupSize?}}{../ns-2/srm.tcl.html}{Agent/SRM::groupSize?} 
  returns the agent's current estimate of the multicast group size.
\item
  \fcnref{\proc[]{distances?}}{../ns-2/srm.cc.html}{SRMAgent::command}
  returns a list of key-value pairs of distances;
  the key is the address of the agent, 
  the value is the estimate of the distance to that agent.
  The first element is the address of this agent, and the distance of 0.
\item
  \fcnref{\proc[]{distance?}}{../ns-2/srm.cc.html}{SRMAgent::command}
  returns the distance to the particular agent specified as argument.
\end{list}
\begin{program}
  $srm(i) groupSize?    \; returns $srm(i)'s estimate of the group size;
  $srm(i) distances?    \; returns list of \tup{address, distance} tuples;
  $srm(i) distance? 257 \; returns the distance to agent at address 257;
\end{program}

\subsubsection{Tracing}
Each object writes out trace information that can be used to track the
progress of the object in its error recovery.
Each trace entry is of the form:
\begin{program}
\tup{prefix} \tup{tag} \tup{type of entry} \tup{values}
\end{program}
The prefix is as describe in the previous subsection for statistics.
The tag is {\bf Q} for request objects, {\bf P} for repair objects, and
{\bf S} for session objects.
The following types of trace entries and parameters are written by each
object:

\centerline{\small\renewcommand{\arraystretch}{1.3}
\begin{tabular}{rclp{2in}}\hline
      & Type of &              & \\
  Tag & Object  & Other values & Comments\\ \hline
  Q & DETECT & & \\
  Q & INTERVALS & C1 \tup{C1\_} C2 \tup{C2\_} dist \tup{distance} i \<backoff\_> & \\
  Q & NTIMER & at \tup{time} & Time the request timer will fire \\
  Q & SENDNACK & & \\
  Q & NACK & IGNORE-BACKOFF \tup{time} & Receive NACK, ignore other NACKs until
  \tup{time} \\
  Q & REPAIR & IGNORES \tup{time} & Receive REPAIR, ignore NACKs until \tup{time}  \\
  Q & DATA & & Agent receives data instead of repair.  Possibly indicates out of order arrival of data. \\ \hline
  P & NACK & from \tup{requester} & Receive NACK, initiate repair \\
  P & INTERVALS & D1 \tup{D1\_} D2 \tup{D2\_} dist \tup{distance} & \\
  P & RTIMER & at \tup{time} & Time the repair timer will fire \\
  P & SENDREP & \\
  P & REPAIR & IGNORES \tup{time} & Receive REPAIR, ignore NACKs until \tup{time} \\
  P & DATA & & Agent receives data instead of repair.  Indicates premature request by an agent. \\ \hline
  S & SESSION & & logs session message sent \\ \hline
\end{tabular}}
The following illustrates a typical trace for a single loss and recovery.
\begin{verbatim}
 3.5543 n 1 m <1:1> r 0 Q DETECT
 3.5543 n 1 m <1:1> r 1 Q INTERVALS C1 2.0 C2 0.0 d 0.0105 i 1
 3.5543 n 1 m <1:1> r 1 Q NTIMER at 3.57527
 3.5685 n 2 m <1:1> r 0 Q DETECT
 3.5685 n 2 m <1:1> r 1 Q INTERVALS C1 2.0 C2 0.0 d 0.021 i 1
 3.5685 n 2 m <1:1> r 1 Q NTIMER at 3.61053
 3.5753 n 1 m <1:1> r 1 Q SENDNACK
 3.5753 n 1 m <1:1> r 2 Q INTERVALS C1 2.0 C2 0.0 d 0.0105 i 2
 3.5753 n 1 m <1:1> r 2 Q NTIMER at 3.61727
 3.5753 n 1 m <1:1> r 2 Q NACK IGNORE-BACKOFF 3.59627
 3.5828 n 3 m <1:1> r 0 Q DETECT
 3.5828 n 3 m <1:1> r 1 Q INTERVALS C1 2.0 C2 0.0 d 0.032 i 1
 3.5828 n 3 m <1:1> r 1 Q NTIMER at 3.6468
 3.5854 n 0 m <1:1> r 0 P NACK from 257
 3.5854 n 0 m <1:1> r 1 P INTERVALS D1 1.0 D2 0.0 d 0.0105
 3.5854 n 0 m <1:1> r 1 P RTIMER at 3.59586
 3.5886 n 2 m <1:1> r 2 Q INTERVALS C1 2.0 C2 0.0 d 0.021 i 2
 3.5886 n 2 m <1:1> r 2 Q NTIMER at 3.67262
 3.5886 n 2 m <1:1> r 2 Q NACK IGNORE-BACKOFF 3.63062
 3.5959 n 0 m <1:1> r 1 P SENDREP
 3.5959 n 0 m <1:1> r 1 P REPAIR IGNORES 3.62736
 3.5971 n 4 m <1:1> r 0 Q DETECT
 3.5971 n 4 m <1:1> r 1 Q INTERVALS C1 2.0 C2 0.0 d 0.0425 i 1
 3.5971 n 4 m <1:1> r 1 Q NTIMER at 3.68207
 3.5971 n 5 m <1:1> r 0 Q DETECT
 3.5971 n 5 m <1:1> r 1 Q INTERVALS C1 2.0 C2 0.0 d 0.042 i 1
 3.5971 n 5 m <1:1> r 1 Q NTIMER at 3.68107
 3.6029 n 3 m <1:1> r 2 Q INTERVALS C1 2.0 C2 0.0 d 0.032 i 2
 3.6029 n 3 m <1:1> r 2 Q NTIMER at 3.73089
 3.6029 n 3 m <1:1> r 2 Q NACK IGNORE-BACKOFF 3.66689
 3.6102 n 1 m <1:1> r 2 Q REPAIR IGNORES 3.64171
 3.6172 n 4 m <1:1> r 2 Q INTERVALS C1 2.0 C2 0.0 d 0.0425 i 2
 3.6172 n 4 m <1:1> r 2 Q NTIMER at 3.78715
 3.6172 n 4 m <1:1> r 2 Q NACK IGNORE-BACKOFF 3.70215
 3.6172 n 5 m <1:1> r 2 Q INTERVALS C1 2.0 C2 0.0 d 0.042 i 2
 3.6172 n 5 m <1:1> r 2 Q NTIMER at 3.78515
 3.6172 n 5 m <1:1> r 2 Q NACK IGNORE-BACKOFF 3.70115
 3.6246 n 2 m <1:1> r 2 Q REPAIR IGNORES 3.68756
 3.6389 n 3 m <1:1> r 2 Q REPAIR IGNORES 3.73492
 3.6533 n 4 m <1:1> r 2 Q REPAIR IGNORES 3.78077
 3.6533 n 5 m <1:1> r 2 Q REPAIR IGNORES 3.77927
\end{verbatim}


The logging of request and repair traces is done by
\fcnref{\proc[]{SRM::evTrace}}{../ns-2/srm.tcl}{SRM::evTrace}.
However, the routine
\fcnref{\proc[]{SRM/Session::evTrace}}{../ns-2/srm.tcl}{SRM/Session::evTrace},
overrides the base class definition of \proc[]{srm::evTrace},
and writes out nothing.
The user can override these methods and achieve greater
flexibility in their logging options.

\subsection{Architecture and Internals}
\label{sec:architecture}

The SRM agent implementation splits the protocol functions
into packet handling, error recovery, and session message activity.

Packet handling consists of forwarding application data messages,
sending and receipt of control messages.
These activities are executed by C++ methods.

Error detection is done in C++ due to reciept of messages.
However, the error recovery is entirely done through 
instance procedures in OTcl.

The sending and processing of messages is accomplished in C++;
the policy about when these messages should be sent is decided
by instance procedures in OTcl.

\paragraph{Packet Handling: Processing received messages}
The
\fcnref{\fcn[]{recv}}{../ns-2/srm.cc}{SRMAgent::recv}
method can receive four type of messages:
data, request, repair, and session messages.
The method assumes that
the agent is a member of the multicast group, and 
therefore will get a copy of each message sent by it to the group.

\subparagraph{Processing Data Packets}
The agent does not generate any data messages.
The user has to specify an external agent to generate traffic.
The \fcn[]{recv} method must distinguish between
locally originated data that must be sent to the multicast group,
and data received from multicast group that must be processed.
Therefore, the application agent must
set the packet's destination address to zero.

For locally originated data, 
the agent adds the appropriate SRM headers,
sets the destination address to the multicast group, 
and forwards the packet to its target.

On receiving a data message from the group,
\fcnref{\fcn[sender, msgid]{recv\_data}}{../ns-2/srm.cc}{SRMAgent::recv\_data}
will update its state marking message
\tup{sender, msgid} received,
and possibly trigger requests if it detects losses.
In addition, if the message was an older message received out of order,
then there must be a pending request or repair that must be cleared.
In that case, the compiled object invokes the OTcl instance procedure,
\fcnref{\proc[sender,
  msgid]{recv-data}}{../ns-2/srm.tcl}{Agent/SRM::recv-data}%
\footnote{Technically,
  \fcn[]{recv\_data} invokes the instance procedure
  \|recv data \tup{sender} \tup{msgid}|,
  that then invokes \proc[]{recv-data}.}.

Currently, there is no provision for the receivers
to actually receive any application data.
The agent does not also store any of the user data.
It only generates repair messages of the appropriate size,
defined by the instance variable \|packetSize\_|.
However, the agent assumes that any application data
is placed in the data portion of the packet,
pointed to by \|packet->accessdata()|.

\subparagraph{Processing Request Packets}
On receiving a request, 
\fcnref{\fcn[sender, msgid]{recv\_rqst}}{../ns-2/srm.cc}{SRMAgent::recv\_rqst}
will check whether it needs to schedule requests for other missing data.
If it has received this request
before it was aware that the source had generated this data message
(\ie, the sequence number of the request is higher than 
the last known sequence number of data from this source),
then the agent can infer that it is missing this, as well as
data between the last known sequence number and that on the request;
it schedules requests for all of this data, and returns.
On the other hand, if the sequence number of the request is less
than the last known sequence number from the source,
then the agent can be in one of three states:
(1) it does not have this data, and has a request pending for it,
(2) it has the data, and has seen an earlier request,
    upon which it has a repair pending for it, or
(3) it has the data, and it should instantiate a repair.
All of these error recovery mechanisms are done in OTcl,
and \fcn[]{recv\_rqst} invokes the instance procedure
\fcnref{\proc[sender, msgid,
  requester]{recv-rqst}}{../ns-2/srm.tcl}{Agent/SRM::recv-rqst}
for further processing.

\subparagraph{Processing Repair Packets}
On receiving a repair, 
\fcnref{\fcn[sender, msgid]{recv\_repr}}{../ns-2/srm.cc}{SRMAgent::recv\_repr}
will check whether it needs to schedule requests for other missing data.
If it has received this repair
before it was aware that the source had generated this data message
(\ie, the sequence number of the repair is higher than 
the last known sequence number of data from this source),
then the agent can infer that it is missing all
data between the last known sequence number and that on the repair;
it schedules requests for all of this data,
marks this message as received, and returns.
On the other hand, if the sequence number of the request is less
than the last known sequence number from the source,
then the agent can be in one of three states:
(1) it does not have this data, and has a request pending for it,
(2) it has the data, and has seen an earlier request,
    upon which it has a repair pending for it, or
(3) it has the data, and probably scheduled a repair for it at some time;
    after error recovery, its holddown timer (equal to three times its
    distance to some requestor) expired, at which time the pending object
    was cleared.  In this last situation, the agent will simply ignore
    the repair, for lack of being able to do anything meaningful.
All of these error recovery mechanisms are done in OTcl,
and \fcn[]{recv\_repr} invokes the instance procedure
\fcnref{\proc[sender,
  msgid]{recv-rqst}}{../ns-2/srm.tcl}{Agent/SRM::recv-rqst}
for further processing.

\subparagraph{Receiving Session Packets}
On receiving a session message,
the agent updates its sequence numbers for all active sources,
and computes its instantaneous distance to the sending agent if possible.
The agent will ignore earlier session messages from a group member,
if it has received a later one out of order.

Session message processing is done in
\fcnref{\fcn[]{recv\_sess}}{../ns-2/srm.cc}{SRMAgent::recv\_sess}.
The format of the session message is:
\tup{count of tuples in this message, list of tuples},
where each tuple indicates the
\tup{sender id, last sequence number from the source, time the last
  session message was received from this sender, time that that message
  was sent}.
The first tuple is the information about the local agent%
\footnote{Note that this implementation of session message handling
  is subtly different from that used in \emph{wb} or described in
  \cite{Floy95:Reliable} in that, in the other schemes, agents
  disseminate a list of the data actually available at that agent,
  whereas we currently disseminate a list of the last message we are
  aware of.
  This will be fixed at some point in time.}.


\subsection{Timer Based Functions}
\label{sec:timers}

In the last section,
we described the agent behaviour when it receives a message.
Recall that the agent does not generate any data.
All control messages are sent based on timer settings.
This section describes the mehanisms to set timers, and send these messages.



\subsection{Extending the Base Class Agent}
\label{sec:extensions}


\subsubsection{Fixed Timers}


\subsubsection{Adaptive Timers}


\end{document}

### Local Variables:
### mode: latex
### comment-column: 60
### backup-by-copying-when-linked: t
### file-precious-flag: nil
### End:
