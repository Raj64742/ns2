\documentclass{article}

%\usepackage{times}
%\usepackage[T1]{fontenc}

\usepackage{nsDoc}

\begin{document}

\title{\nsTcl\ internals documentation}
\author{%
  Kevin Fall \tup{kfall@ee.lbl.gov}\\
  Kannan Varadhan \tup{kannan@catarina.usc.edu}}
\date{\today}

% \maketitle

\section{\ns\ Documentation: Preamble}
\label{sec:nsDocumentation}

\xref{\ns}{http://www-nrg.ee.lbl.gov/ns/}
\xref{\copyright}{../copyright.html}
is LBNL's \underline{N}etwork \underline{S}imulator \cite{ns}.
The simulator is written in C++;
it uses OTcl as a command and configuration interface.
\ns~v2 has three substantial changes from \ns~v1:
(1) the more complex objects in \ns~v1
    have been decomposed into simpler components
    for greater flexibility and composability;
(2) the configuration interface is now OTcl, 
    an object oriented version of Tcl; and
(3) the interface code to the OTcl interpreter is
    separate from the main simulator.
This document describes the portions of \ns~v2
that interact with the OTcl interpreter.

In this document,
we use the term ``interpreter''
to be synonymous with the OTcl interpreter.
The code to interface with the interpreter resides
in a separate directory, \code{Tcl}.
The rest of the simulator code resides in the directory, \code{ns-2}.
We will use the notation \Tclf{\tup{file}}\
to refer to a particular \tup{file}\ in the
\code{Tcl}\ directory.
Similarly, we will use the notation, \nsf{\tup{file}}
to refer to a particular \tup{file}\ in the \code{ns-2} directory.

\danger
A final note on notation.
All of our documentation falls into one of three categories:
A broad overview of the section,
details pertinent to complex simulation configurations,
code samples,
and finally,
esoteric details that are not required to program or use the simulator.
Such esoteric details are flagged with a ``danger bend'' at the top of
the paragraph, similar to the manner in which this paragraph is marked.

\section{Introduction}
\ns\ is an object oriented simulator,
written in C++, with an OTcl interpreter as a frontend.
The simulator supports a class hierarchy in C++,
also called the compiled hierarchy in this document, 
and a similar class hierarchy within the OTcl interpreter.
The two hierarchies are closesly related to each other;
from the user's perspective,
there is a one-to-one correspondence
between a class in the interpreted hierarchy
and one in the compiled hierarchy.
Users create new simulator objects through the interpreter;
these objects are instantiated within the interpreter, 
and are closesly mirrored by a corresponding object
in the compiled hierarchy.
The interpreted class hierachy is automatically established through
methods defined in the class TclClass.
user instantiated objects are mirrored through methods
defined in the class TclObject.


There are a number of classes defined in \Tclf{}.
We only focus on the six that are used in \ns:
The \href{Class Tcl}{Section}{sec:Tcl} contains the methods that
C++ code will use to access the interpreter.
The \href{class TclObject}{Section}{sec:TclObject}
is the base class for all simulator objects that are also mirrored 
in the compiled hierarchy.
The \href{class TclClass}{Section}{sec:TclClass} defines
the interpreted class hierarchy, and 
the methods to permit the user to instantiate TclObjects.
The \href{class TclCommand}{Section}{sec:TclCommand}
is used to define simple global interpreter commands.
The \href{class EmbeddedTcl}{Section}{sec:EmbeddedTcl}
contains the methods to load higher level builtin commands
that make configuring simulations easier.
Finally, the \href{class InstVar}{Section}{sec:InstVar}
contains methods to access C++ member variables
as OTcl instance variables.

\section{Class Tcl}
\label{sec:Tcl}

The \clsref{Tcl}{../Tcl/Tcl.h} encapsulates the actual instance of
the OTcl interpreter, and provides the methods
to access and communicate with that interpreter.
The methods described in this section are relevant to the
\ns\ programmer who is writing C++ code.
The class provides methods for the following operations:
\begin{list}{\textbullet}{}
\item obtain a reference to the Tcl instance;
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[]{Tc::instance}
%    \end{list}
%  }
\item invoke OTcl procedures through the interpreter;
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[char* $s$]{Tcl::eval}
%    \item \fcn[const char* $s$]{Tcl::evalc}
%    \item \fcn[]{Tcl::eval}
%    \item \fcn[const char* $\mathit{fmt}$, \ldots]{Tcl::evalf}
%    \end{list}
%  }
\item retrieve, or pass back results to the interpreter;
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[const char* $s$]{Tcl::result}
%    \item \fcn[const char* $\mathit{fmt}$, \ldots]{Tcl::resultf}
%    \item \fcn[]{Tcl::result}
%    \end{list}
%  }
\item report error situations and exit in an uniform manner; and
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[const char* $s$]{Tcl::error}
%    \end{list}
%  }
\item store and lookup ``TclObjects''.
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[const char* $s$]{Tcl::lookup}
%    \item \fcn[TclObject* $o$]{Tcl::enter}
%    \item \fcn[TclObject* $o$]{Tcl::remove}
%    \end{list}
%  }
\item acquire direct access to the interpreter.
%  {\tt
%    \begin{list}{}{}
%    \item \fcn[]{Tcl::interp}
%    \end{list}
%  }
\end{list}
We describe each of the methods in the following subsections.

\subsection{Obtain a Reference to the class Tcl instance}
\label{sec:instance}

A single instance of the class is declared in \Tclf{Tcl.cc}
as a static member variable;
the programmer must obtain a reference to this instance
to access other methods described in this section.
The statement required to access this instance is:
\begin{verbatim}
        Tcl& tcl = Tcl::instance();
\end{verbatim}

\subsection{Invoking OTcl Procedures}
\label{sec:Invoke}
There are four different methods to invoke an OTcl command
through the instance, \code{tcl}.
They differ essentially in their calling arguments.
Each function passes a string to the interpreter,
that then evaluates the string in a global context.
These methods will return to the caller if the interpreter returns TCL\_OK.
On the other hand, if the interpreter returns TCL\_ERROR,
the methods will call \proc{tkerror}.
The user can overload this procedure to selectively disregard
certain types of errors.
Such intricacies of OTcl programming are outside the
scope of this document.
\href{The next section}{Section}{sec:Result}
describes methods to access the result returned by the interpreter.
\begin{itemize}
\item \fcnref{\fcn[char* $s$]{tcl.eval}}{../Tcl/Tcl.cc}{Tcl::eval}
  invokes \fcn[]{Tcl\_GlobalEval} to execute $s$ through the interpreter.

\item \fcnref{\fcn[const char* $s$]{tcl.evalc}}{../Tcl/Tcl.cc}{Tcl::evalc}
  preserves the argument string $s$.
  It copies the string $s$ into its internal buffer;
  it then invokes the previous \fcn[char* $s$]{eval} on the internal buffer.

\item \fcnref{\fcn{tcl.eval}}{../Tcl/Tcl.cc}{Tcl::eval}
  assumes that the command is already stored in the class' internal
  \code{bp\_}, and directly invokes \code{tcl.eval(char* bp\_)}.
  A handle to the buffer itself is available through the method
  \fcnref{\fcn{tcl.buffer}}{../Tcl/Tcl.h}{Tcl::buffer}.

\item
  \fcnref{\fcn[const char* $s$, \ldots]{tcl.evalf}}{../Tcl/Tcl2.cc}{Tcl::evalf}
  is a \code{Printf}(3) like equivalent.
  It uses \code{vsprintf}(3) internally to create the input string.
\end{itemize}
As an example, here are some of the ways of using the above methods:
\begin{verbatim}
        Tcl& tcl = Tcl::instance();
        char wrk[128];
        strcpy(wrk, "Simulator set NumberInterfaces_ 1");
        tcl.eval(wrk);

        sprintf(tcl.buffer(), "Agent/SRM set requestFunction_ %s", "Fixed");
        tcl.eval();
                
        tcl.evalc("puts stdout {hello world}");
        tcl.evalf("%s request %d %d", name_, sender, msgid);
\end{verbatim}

\subsection{Passing Results to/fro the Interpreter}
\label{sec:Result}

When the interpreter invokes a C++ method,
it expects the result back in the private member variable,
\code{tcl\_->result}.
Two methods are available to set this variable.
\begin{list}{\textbullet}{}
\item \fcnref{\fcn[const char* $s$]{tcl.result}}{../Tcl/Tcl.h}{Tcl::result}

        Pass the result string $s$ back to the interpreter.
\item
  \fcnref{\fcn[const char* fmt, \ldots]{tcl.resultf}}{../Tcl/Tcl2.cc}{Tcl::resultf}

        \code{varargs}(3) variant of above
        to format the result using \code{vsprintf}(3),
        pass the result string back to the interpreter.
\end{list}
\begin{verbatim}
        if (strcmp(argv[1], ``now'') == 0) {
                tcl.resultf("%.17g", clock());
                return TCL_OK;
        }
        tcl.result("Invalid operation specified");
        return TCL_ERROR;
\end{verbatim}

Likewise, when a C++ method invokes an OTcl command,
the interpreter returns the result in \code{tcl\_->result}.
\begin{list}{\textbullet}{}
\item \fcnref{\fcn{tcl.result}}{../Tcl/Tcl.h}{Tcl::result}
      must be used to retrieve the result.
      Note that the result is a string, that must be converted
      into an internal format appropriate to the type of result.
\end{list}
\begin{verbatim}
        tcl.evalc("Simulator set NumberInterfaces_");
        char* ni = tcl.result();
        if (atoi(ni) != 1)
                tcl.evalc("Simulator set NumberInterfaces_ 1");
\end{verbatim}
        
\subsection{Error Reporting and Exit}
\label{sec:ErrorReporting}

This method provides a uniform way to report errors in the compiled code.
\begin{list}{\textbullet}{}
\item \fcnref{\fcn[const char* $s$]{tcl.error}}{../Tcl/Tcl.cc}{Tcl::error}
performs the following functions:
write $s$ to stdout; write \code{tcl\_->result} to stdout;
exit with error code 1.
\end{list}
\begin{verbatim}
        tcl.resultf("cmd = %s", cmd);
        tcl.error("invalid command specified");
        /*NOTREACHED*/
\end{verbatim}

Note that
there are minor differences between returning TCL\_ERROR
\href{as we did in the previous subsection}{Section}{sec:Result},
and calling \fcn[]{Tcl::error}.
The former generates an exception within the interpreter;
the user can trap the exception and possibly recover from the error.
If the user has not specified any traps, 
the interpreter will print a stack trace and exit.
However, if the code invokes \fcn[]{error},
then the simulation user cannot trap the error;
in addition, \ns\ will not print any stack trace.

\subsection{Hash Functions within the Interpreter}
\label{sec:HashTables}

\ns\ stores a reference to every TclObject in the compiled hierarchy
in a hash table;
this permits quick access to the objects.
The hash table is internal to the interpreter.
\ns\ uses the name of the \code{TclObject} as the key
to enter, lookup, or delete the TclObject in the hash table.
\begin{list}{\textbullet}{}
\item \fcnref{\fcn[TclObject* $o$]{tcl.enter}}{../Tcl/Tcl.cc}{Tcl::enter}
        will insert a pointer to the TclObject $o$ into the hash table.
        It is used by
        \fcnref{\fcn[]{TclClass::create\_shadow}}{../Tcl/Tcl.cc}{TclClass::create\_shadow}
        to insert an object into the table, when that object is created.
\item \fcnref{\fcn[char* $s$]{tcl.lookup}}{../Tcl/Tcl.h}{Tcl::lookup}
        will retrieve the TclObject with the name $s$.
        It is used by
        \fcnref{\fcn[]{TclObject::lookup}}{../Tcl/Tcl.h}{TclObject::lookup}.
\item \fcnref{\fcn[TclObject* $o$]{tcl.remove}}{../Tcl/Tcl.cc}{Tcl::remove}
        will delete references to the TclObject $o$ from the hash table.
        It is used by
        \fcnref{\fcn[]{TclClass::delete\_shadow}}{../Tcl/Tcl.cc}{TclClass::delete\_shadow}
        to remove an existing entry from the hash table,
        when that object is deleted.
\end{list}
These functions are used internally by
the class TclObject and class TclClass.

\subsection{Other Operations on the Interpreter}
\label{sec:other}

If the above methods are not sufficient,
then we must acquire the handle to the interpreter,
and write our own functions.
\begin{list}{\textbullet}{}
\item \fcnref{\fcn{tcl.interp}}{../Tcl/Tcl.h}{Tcl::interp}
        returns the handle to the interpreter that is stored
        within the class Tcl.
\end{list}

\section{Class TclObject}
\label{sec:TclObject}

\clsref{TclObject}{../Tcl/Tcl.h} is the ``most'' basic class in \ns.
This class is the base class for most of the other classes
in the interpreted and compiled hierarchies.
Every object  in the class TclObject that is created by the user,
is instantiated within the interpreter;
and an equivalent shadow object is created in the compiled hierarchy.
The two objects are closely associated with each other.
The class TclClass, described in the next section,
contains the mechanisms that perform this shadowing.

In the rest of this document, we often refer to an object as a TclObject.
By this, we refer to a particular object that is either in the class
TclObject, or in a class that is derived from the class TclObject.
If it is necessary, we will explicitly qualify whether that object is
an object within the interpreter, or an object within the compiled code.
In such cases,
we will use the abbreviations ``interpreted TclObject'', and
``compiled TclObject'' to refer to TclObjects within the interpreter, 
and within the compiled code respectively.

\paragraph{Differences from \ns~v1}
Unlike \ns~v1, the class TclObject
subsumes the earlier functions of the NsObject class.
It therefore stores the
\href{interface variable bindings}{Section}{sec:VarBinds}
that tie OTcl instance variables in the interpreted object
to corresponding C++ member variables in the compiled object.
The binding is stronger than in \ns~v1 in that
any changes to the OTcl variables are trapped,
and the current C++ and OTcl values
are made consistent after each access through the interpreter.
The consistency is done through the
\href{class InstVar}{Section}{sec:InstVar}.
Also unlike \ns~v1, objects in the class TclObject
are no longer stored as a global link list.
Instead, they are stored in a hash table in the
\href{class Tcl}{Section}{sec:HashTables}.

\paragraph{Example showing use of TclObjects}
As an example, the
\clsref{Classifier}{../ns-2/classifier.h}
is a compiled class derived from the class TclObject.
Here is how a node is put together as a collection of
Address Classifiers (\clsref{AddressClassifier}{../ns-2/classifier-addr.h})
\begin{verbatim}
        set classifier_ [new Classifier/Addr]
        $classifier_ set mask_ 0xffffff
        $classifier_ set shift_ 8
        $classifier_ install $id_ [$dmux_ entry]
\end{verbatim}
The first line of the above example shows how a TclObject is 
\href{created (or destroyed)}{Section}{sec:Creation};
the next two lines how the TclObject is configured through
\href{the bound variables}{Section}{sec:VarBinds};
and finally, in the last line,
the interpreted object invokes a C++ method
\href{as if they were an instance procedure}{Section}{sec:commands}.

\subsection{Creating and Destroying TclObjects}
\label{sec:Creation}

The user creates or destroys TclObjects
using the procedures \proc[]{new} and \proc[]{delete};
these procedures are defined in \Tclf{tcl-object.tcl}.
They can be used to create and destroy objects in all classes,
including TclObjects.%
\footnote{As an example, the classes Simulator, Node, Link, or rtObject,
are classes that are \emph{not} derived from the class TclObject.
Objects in these classes  are not, therefore, TclObjects.
However, a Simulator, Node, Link, or route Object is also instantiated
using the \code{new} procedure in \ns.}.
In this section,
we describe the internal actions executed when a TclObject
is created.

\paragraph{Creating TclObjects}
By using \proc[]{new}, the user creates an interpreted TclObject.
The interpreter will execute the constructor for that object, \proc[]{init},
passing it any arguments provided by the user.
\ns\ has to simultaneously create the compiled object.
The shadow object gets created by the 
base class TclObject's constructor.
Therefore, when writing a constructor for a class derived from TclObject,
the programmer must call the parent class constructor first,
to ensure that the shadow object gets created correctly.
\proc[]{new} returns a handle to the object, that can then be used
for further operations upon that object.

The following sequence of actions are performed by the interpreter
as part of instantiating a new TclObject.
For ease of exposition, we describe the steps that are executed
to create a Classifier/Addr object.
By convention in \ns, Classifier/Addr is a subclass of Classifier, 
is a subclass of TclObject.
The steps are:
\begin{enumerate}
\item
  Obtain an unique handle for the new Classifier/Addr object
  from the TclObject name space.
  The handle is returned to the user.
  Most handles in \ns\ have the form \code{\_o\tup{NNN}}, where \tup{NNN}
  is an integer.  This handle is created by
  \fcnref{\proc{getid}}{../Tcl/tcl-object.tcl}{TclObject::getid}.
\item Execute the constructor for the new Classifier/Addr object.
  Any user-specified arguments are passed as arguments to the constructor.
  This constructor must invoke the constructor
  associated with the parent class,
  \ie, the constructor for the class Classifier.

  Note that each constructor,
  in turn invokes its parent class' constructor \textit{ad nauseum}.
  The last constructor in \ns\ is
  \fcnref{the TclObject constructor}{../Tcl/tcl-object.tcl}{TclObject::init}.
  This constructor is responsible for setting up the shadow object, and 
  performing other initialisations and bindings, as we explain below.
  \emph{It is preferable to call the parent constructors first before
    performing the initialisations required in this class.}
  This allows the shadow objects to be set up,
  and the variable bindings established.
\item The TclObject constructor invokes the instance procedure
  \proc[]{create-shadow} for the class Classifier/Addr.

  The shadow object for the Classifier/Addr object is
  a compiled object in the class AddressClassifier.
\item When the shadow object is created,
  \ns\ calls all of the constructors for the compiled object,
  each of which may establish variable bindings for objects in that class,
  and other necessary initialisations.
  In the next section, we will describe how these variable bindings are setup.
  Hence our earlier injunction that it is preferable to invoke the parent
  constructors prior to performing the class initialisations.
\item After the shadow object is successfully created,
  \fcnref{\fcn{create\_shadow}}{../Tcl/Tcl.cc}{TclClass::create\_shadow}
  \begin{enumerate}
  \item adds the new object to hash table of TclObjects described earlier.
  \item makes \proc[]{cmd} an instance procedure of the newly created
    interpreted object.
    The procedure will result in invoking the \fcn[]{command}
    method of the compiled object.
    In the next subsection, we describe how the \code{command}
    method is defined, and how they are invoked.
  \end{enumerate}
\end{enumerate}
Note that all of the above shadowing mechanisms works only when
the user creates a new TclObject through the interpreter.
It will not work if the programmer creates a compiled TclObject
unilaterally.
Therefore, the programmer is enjoined not to create ``\code{new TclObject}''s
in the C++ code.

\paragraph{Deletion of TclObjects}
Conversely, the \code{delete} operation simply invokes the
instance procedure \code{delete-shadow}, that in turn invokes
\fcnref{the equivalent compiled method}{%
  ../Tcl/Tcl.cc}{TclClass::delete\_shadow}, 
and then destroys the interpreted object.

For example,
\fcnref{\proc[\tup{scheduler}]{use-scheduler}}{%
  ../ns-2/ns-lib.tcl}{Simulator::use-scheduler}
uses the \code{delete} procedure to remove the default list scheduler,
and instantiate an alternate scheduler in its place.
\begin{verbatim}
        Simulator instproc use-scheduler type {
                $self instvar scheduler_

                # first delete the existing list scheduler
                delete scheduler_
                set scheduler_ [new Scheduler/$type]
        }
\end{verbatim}

\subsection{Variable Bindings}
\label{sec:VarBinds}

In most cases,
access to compiled member variables is restricted to compiled code,
and access to interpreted member variables is likewise
confined to access via interpreted code;
however, it is possible to establish bi-directional bindings
such that both the interpreted member variable
and the compiled member variable access the same data, 
and changing the value of either variable
changes the value of the corresponding paired variable to same value.

The programmer can bind variable correspond to five data types:
Reals (\fcnref{\fcn[]{tcl.bind}}{../Tcl/Tcl.cc}{TclObject::bind}),
Bandwidth valued variables
(\fcnref{\fcn[]{tcl.bind\_bw}}{../Tcl/Tcl.cc}{TclObject::bind\_bw}),
Time valued variables
(\fcnref{\fcn[]{tcl.bind\_time}}{../Tcl/Tcl.cc}{TclObject::bind\_time}),
Integers (\fcnref{\fcn[]{tcl.bind}}{../Tcl/Tcl.cc}{TclObject::bind}),
and finally,
Booleans (\fcnref{\fcn[]{tcl.bind\_bool}}{../Tcl/Tcl.cc}{TclObject::bind\_bool}).
All of the functions above takes two arguments,
the name of an OTcl variable,
and the address of the corresponding compiled member variable that must
be linked.
Typically, these calls are invoked by the constructor of the class that
needs to make some of its member variables accessible through the interpreter.
However, this need not always be the case.
We will discuss such alternate methods
when we describe \href{the class InstVar}{Section}{sec:InstVar}
in detail later.

The syntax of how these values can be specified in OTcl is different
for each variable type.
\begin{itemize}
\item Real and Integer valued variables are specified in the ``normal'' form.
\item Bandwidth is specified as a real value, optionally
  suffixed by a `k' or `K' to mean kilo-quantities, or `m' or `M' to
  mean mega-quantities.
  A final optional suffix of `B' indicates that the quantity expressed
  is in Bytes per second.
  The default is bandwidth expressed in bits per second.
\item Time is specified as a real value, optionally suffixed by a
  `m' to express time in milli-seconds, `n' to express time in
  nano-seconds, or `p' to express time in pico-seconds.
  The default is time expressed in seconds.
\item Booleans can be expressed either as an integer, or as `T' or `t'
  for true.  Subsequent characters after the first letter are ignored.
  If the value is neither an integer, nor a true value,
  then it is assumed to be false.
\end{itemize}

\danger
The actual binding is done by instantiating objects in the
class InstVar.  Each object in the class InstVar binds 
one compiled member variable to one interpreted member variable.
Each TclObject stores a list of InstVar objects corresponding
to each of its member variable that is bound in this fashion.
The head of this list is stored in its member variable
\code{instvar\_}.
\closedanger

The process of binding also initialises the member variable.
This initialisation is done by the instance procedure,
\fcnref{init-instvar}{../Tcl/tcl-object.tcl}{TclObject::init-instvar}.
It walks up its class hierarchy, finding the first class
in which the appropriate class variable is defined.
It then sets the interpreted member variable for that object
to the value defined by the class variable.
This process of setting the interpreted member variable then
also sets the value of the compiled member variable.
If no member variable is defined, then a warning message is printed
out by the routine
\fcnref{warn-instvar}{../Tcl/tcl-object.tcl}{TclObject::warn-instvar},
and the function returns.
Most of the bind initialisation values are defined in
\nsf{tcl/lib/ns-default.tcl}.

Here is a contrived example to show how the binding mechanism works.
Consider an interpreted object in the class LinkDelay/Transit,
subclass of class LinkDelay, whose corresponding shadow object is in 
the class TransitLinkDelay, subclass of class LinkDelay.
Let the TransitLinkDelay constructor bind the variables as shown below:
\begin{verbatim}
        TransitLinkDelay::TransitLinkDelay()
        {
                bind_bw("bandwidth_", &bandwidth_);
                bind_time("delay_", &delay_);
                bind_bool("linkState_", &linkState_);
                bind_int{"linkID_", &linkID_);
        }
\end{verbatim}
and let us assume that the following class variables are defined,
\begin{verbatim}
        Transit/LinkDelay set bandwidth_ 5Mb
        Transit/LinkDelay set delay_     2ms
        Transit set linkState_       True
\end{verbatim}
Then, a newly instantiated LinkDelay/Transit object will have 
default initialisations for  \code{bandwidth\_} 5Mb and \code{delay\_} 2ms,
\code{linkState\_} is set to ``True'' using the parent class' variable;
however, since no class variable is defined for \code{linkID\_},
\code{warn-instvar} will print an error message, and
not initialiset that variable.
The user can redefine \code{warn-instvar}
if they wish to take other action in such cases.

\subsection{\code{command} Methods: Definition and Invocation}
\label{sec:Commands}

One of the instance procedures defined
when a new TclObject is created is ``\code{cmd}'' .
This procedure invokes the appropriate \code{command} method 
specifying the operation that is to be performed by the method.
These operations method can be invoked in \ns\ in one of two ways:
implicitly, as if there were an instance procedure
with the same name as the operation,  or
explicitly, through the \code{cmd} method.

A typical command function is declared as:

When invoked implicitly, the TclObject instance procedure
\fcnref{\proc{unknown}}{../Tcl/tcl-object.tcl}{TclObject::unknown}
is invoked that in turn invokes the \code{cmd} instance procedure
with the arguments that it was passed.

The alternate method of explicitly invoking
the \code{cmd} instance procedure is useful 
to overload the command procedure
with an instance procedure
 with the same name is defined for that object.
For instance, the \code{class RouteLogic} has an instance procedure called
\code{lookup} that can perform some types of route lookup.  However,
for others, it has to invoke an operation to return the necessary information
through 
\fcnref{\fcn{RouteLogic::command}}{../ns-2/route.cc}{RouteLogic::command}.
Its instance procedure is therefore defined as
\begin{verbatim}
        RouteLogic instproc lookup {nodeid destid} {
                set node [Simulator get-node-by-id $nodeid]
                if {[$node info vars rtObject_] != ""} {
                        return [[$node rtObject?] lookup $destid]
                } else {
                        return [$self cmd lookup $nodeid $destid]
                }
        }
\end{verbatim}
%$
We see that, if the lookup procedure cannot find the necessary information
through appropriately defined objects, then it explicitly
invokes the \code{lookup} operation defined in \code{RouteLogic::command}.

Continuing with the RouteLogic example, we now illustrate how a typical
\code{command} method is defined.
\begin{verbatim}
int RouteLogic::command(int argc, const char*const* argv)
{
        Tcl& tcl = Tcl::instance();
        if (argc == 4) {
                if (strcmp(argv[1], "lookup") == 0) {
                        if (route_ == 0) {
                                tcl.result("routes not computed");
                                return (TCL_ERROR);
                        }
                        int src = atoi(argv[2]) + 1;
                        int dst = atoi(argv[3]) + 1;
                        if (src >= size_ || dst >= size_) {
                                tcl.result("node out of range");
                                return (TCL_ERROR);
                        }
                        tcl.resultf("%d", route_[INDEX(src, dst, size_)] - 1);
                        return (TCL_OK);
                }
        }
        return (TclObject::command(argc, argv));
}
\end{verbatim}
We can make the following observations from this piece of code:
\begin{itemize}
\item The function is called with two arguments:
  \subitem The first argument (\code{argc})
  indicates the number of arguments specified
  in the command line to the interpreter.
  \subitem The command line arguments vector (\code{argv}) consists of
  \subitem --- \code{argv[0]} cntains the name of the method, ``\code{cmd}''.
  \subitem --- \code{argv[1]} specifies the desired operation.
  \subitem --- If the user specified any arguments, then they are placed in
  \code{argv[2\ldots(argc - 1)]}.
  \subitem Note that the arguments are passed as strings, and must be
  converted to the appropriate data type.
\item If the operation is successfully matched, then the result of
  executing the operation is placed in \code{tcl\_->result}.
  We described the technique to return this result
  \hyperref{earlier}{earlier in Section}{}{sec:Result}.
\item The return code is an integer, indicating success (\code{TCL\_OK}),
  or failure (\code{TCL\_ERROR}).
\item If the operation is not matched in this method, it must
  invoke its parent's command method, and return the corresponding result.
  This permits the user to concieve of operations as having the same
  inheritance properties as instance procedures or compiled methods.
  \subitem In the event that this \code{command} method 
  is defined for a class with multiple inheritance, the programmer has the
  liberty to choose one of two implementations:
  \subitem 1) Either they can invoke one of the parent's \code{command}
  method, and return the result of that invocation, or
  \subitem 2) They can each of the parent's \code{command} methods
  in some sequence, and return the result of the first invocation that
  is successful.  If none of them are successful, then they should return
  an error.
\end{itemize}

At this point, we define the following five terms:
procedures, instance procedures, and operations are ``actions'' defined
within the interpreter; functions and methods are C++ ``actions''
defined within compiled code.
\textbf{Procedures} are global or class \code{proc}s
that can be invoked in a global context by any OTcl code.
On the other hand, \textbf{instance procedures} are associated with an
object, and must be executed in a method execution context associated
with a specific object.  The object is accessible within
the particular instance procedure through the special variable
\code{\$self}.
Similarly,
C++ \textbf{functions} are functions that can be invoked without 
reference to an explicit object while \textbf{methods}
are functions that must be invoked in a specific method context.
In the latter case, the object is accessible through the
special variable \code{this}.
In addition, the term \textbf{instproc-like} refers to
an operation that is often invoked
exactly as if it were an instance procedure.
However, the name of that operation
does not correspond to any OTcl instance procedure.
Instead, the instproc-like is defined within
a \fcn[]{command} method for the compiled object.
We will describe how operations are created and executed in
\href{the following sections}{Section}{sec:Commands}.


\section{Class TclClass}
\label{sec:TclClass}

This compiled class (\clsref{TclClass}{../Tcl/Tcl.h})
is a pure virtual class.
Classes derived from this base class provide two functions:
construct the interpreted class hierarchy
to mirror the compiled class hierarchy; and
provide methods to instantiate new TclObjects.
Each such derived class is associated with a particular compiled class
in the compiled class hierarchy, and can instantiate new objects in the
associated class.

As an example, consider a class such as the
class \code{RenoTcpClass}.
It is derived from class \code{TclClass}, and
is associated with the class \code{RenoTcpAgent}.
It will instantiate new objects in the class \code{RenoTcpAgent}.
The compiled class hierarchy for \code{RenoTcpAgent} is that
it derives from \code{TcpAgent}, that in turn derives from \code{Agent},
that in turn derives (roughly) from \code{TclObject}.
\code{RenoTcpClass} is defined as
\begin{verbatim}
        static class RenoTcpClass: public TclClass {
        public:
                RenoTcpClass() : TclClass("Agent/TCP/Reno") {}
                TclObject* create(int argc, const char*const* argv) {
                        return (new RenoTcpAgent());
                }
        } class_reno;
\end{verbatim}
We can make the following observations from this definition:
\begin{enumerate}
\item We need a localised definition that sets up the appropriate methods.
  Hence a static definition following the definition of class
  \code{RenoTcpAgent} is sufficient.
\item This class is associated with the class \code{RenoTcpAgent}, and 
  is used to create new agents in that associated class.
\item The class defines only the constructor, and one additional method,
  to \code{create} instances of the associated TclObject.
\item The constructor specifies the interpreted class explicitly as
  \code{Agent/TCP/Reno}.  This also specifies the interpreted class
  hierarchy implicitly.

  The character slash ('/') is considered as a separator.
  For any given class \code{A/B/C/D}, the class \code{A/B/C/D} is a
  sub-class of \code{A/B/C}, that is itself a sub-class of \code{A/B},
  that, in turn, is a sub-class of \code{A}.  \code{A} itself is a
  sub-class of \code{TclObject}.

  In our case above, the TclClass constructor creates three classes,
  \code{Agent/TCP/Reno} sub-class of \code{Agent/TCP} sub-class of
  \code{Agent} sub-class of \code{TclObject}.
\item The \code{RenoTcpClass::create} method returns TclObjects in the
  class \code{RenoTcpAgent}.
\item A single object in the class \code{RenoTcpClass} is required in order
  to activate these methods.
  This object \code{class\_reno} is declared at compile time.
\item When the user specifies \code{new Agent/TCP/Reno},
  the routine \code{RenoTcpClass::create} is invoked.
\item The arguments vector (\code{argv}) consists of
  \subitem --- \code{argv[0]} contains the name of the object.
  \subitem --- \code{argv[2\ldots4]} contain \code{\$self}, \code{\$class},
  and \code{\$proc}.  Since \code{create} is called through the
  instance procedure \code{create-shadow}, \code{argv[4]} contains
  \code{create-shadow}.
  \subitem --- \code{argv[5\ldots]} contain any additional arguments
  provided by the user.
\end{enumerate}
An example of how arguments are specified during object creation is in the
class \code{Trace}.
\begin{verbatim}
        class TraceClass : public TclClass {
        public:
                TraceClass() : TclClass("Trace") { }
                TclObject* create(int args, const char*const* argv) {
                        if (args >= 5)
                                return (new Trace(*argv[4]));
                        else
                                return NULL;
                }
        } trace_class;
\end{verbatim}
A new Trace object can be created as
\begin{verbatim}
        new Trace "X"
\end{verbatim}

\danger
The mechanism by which the interpreted class hierarchy is constructed is as
follows:
\closedanger
\begin{enumerate}
\item The TclClass object, as part of its creation, causes its constructor
  to be executed.  
\item This constructor calls the TclClass constructor with the name of this
  class that must be specified to the interpreter as its argument.
\item The TclClass constructor only inserts this object into a linked list
  of the TclClass objects.
\item During initialisation of the simulator,
  \fcnref{\fcn{Tcl\_AppInit}}{../ns-2/ns_tclsh.cc}{::Tcl\_AppInit}
  invokes 
  \fcnref{\fcn{TclClass::bind}}{../Tcl/Tcl.cc}{TclClass::bind}
\item This method, \code{bind}, registers each object with the interpreter.
  The procedure,
  \fcnref{\proc{register}}{../Tcl/tcl-object.tcl}{TclObject::register},
  is called with the class name.
  It defines the specified class, as well as any super-classes
  that should be defined.
  This then forms the interpreted class hierarchy.
\item The \code{bind} method then defines instance procedures
  \code{create-shadow} and \code{delete-shadow} for this new class.
\end{enumerate}

\section{Class TclCommand}
\label{sec:TclCommand}

This class (\clsref{TclCommand}{../Tcl/Tcl.h})
provides just the mechanism for \ns\ to export
simple commands to the interpreter, 
that can then be executed within a global context by the interpreter.
There are two functions defined in \nsf{misc.cc}:
\code{ns-random} and \code{ns-version}.
These two functions are initialised by the function
\fcnref{\fcn{init\_misc}}{../ns-2/misc.cc}{::init\_misc},
defined in \nsf{misc.cc};
\code{init\_misc} is invoked by
\fcnref{\fcn{Tcl\_AppInit}}{../ns-2/ns_tclsh.cc}{::Tcl\_AppInit}
during startup.
\begin{itemize}
\item \clsref{VersionCommand}{../ns-2/misc.cc}
  defines the command \code{ns-version}.
  It takes no argument, and returns the current \ns\ version string.
\begin{verbatim}
            % ns-version                # get the current version
            2.0a12
\end{verbatim}

\item \clsref{RandomCommand}{../ns-2/misc.cc}
  defines the command \code{ns-random}.
  With no argument, \code{ns-random} returns an integer,
  uniformly distributed in the interval $[0, 2^{31}-1]$.

  When specified an argument, it takes that argument as the seed.
  If this seed value is 0, the command uses a hueristic seed value;
  otherwise, it sets the seed for the random number generator to the
  specified value.
\begin{verbatim}
            % ns-random                 # return a random number
            2078917053
            % ns-random 0               # set the seed hueristically
            858190129
            % ns-random 23786           # set seed to specified value
            23786
\end{verbatim}
\end{itemize}

We now describe how to define a new command using an example.
The example will define the command \code{say\_hello}.
This command will print the string ``hello, world'',
followed by any command line arguments specified by the user.
Note that, it is generally not advisable to construct
top-level commands that are available to the user.
\begin{enumerate}
\item The command must be defined within a class
  derived from the \code{class TclCommand};
  the constructor for that class invokes the
  \fcnref{TclCommand constructor}{../Tcl/Tcl.cc}{TclCommand::TclCommand}
  with the argument ``say\_hello''.
  The TclCommand constructor
  creates the command that can be invoked by the user.

\item  The class defines a command method.
  This method performs the desired action when the user invokes 
  ``say\_hello''.

  The argument vector (\code{argv}) contains the following:
  
  --- \code{argv[0]} contains the name of the command (\code{say\_hello}).

  --- \code{argv[1\ldots(argc - 1)]} contains additional arguments
  specified on the command line by the user.

  \danger
  When \code{my\_command} is invoked by the user,
  the interpreter calls the C++ method
  \fcnref{\fcn[]{TclCommand::dispatch\_cmd}}{../Tcl/Tcl.cc}{TclCommand::dispatch\_cmd}.
  This method then, in turn, invokes the appropriate command method,
  passing it any arguments that were specified by the user.
  \closedanger
\end{enumerate}
\begin{verbatim}
        #include <streams.h>        // because we are using stream I/O

        class say_hello: public TclCommand {
        public:
                say_hello() : TclCommand("say_hello");
                int command(int argc, const char*const* argv);
        };

        int say_hello::command(int argc, const char*const* argv)
        {
                cout << "hello world:";
                for (int i = 1; i < argc; i++)
                        cout << ' ' << argv[i];
                cout << '\n';
                return TCL_OK;
        }
\end{verbatim}
The above code only sets up the framework for establishing this command.
We still need to activate the code.
This is done by creating an instance of \code{say\_hello} in \code{init\_misc}
(defined in \nsf{misc.cc}) as
\begin{verbatim}
        new say_hello;
\end{verbatim}

Note that there used to be more functions such as \code{ns-at}\ and
\code{ns-now}\ that were accessible in this manner.
Most of these functions have been subsumed into existing classes.
In particular, \code{ns-at}\ and \code{ns-now}\ are accessible
through the
\fcnref{scheduler TclObject}{../ns-2/scheduler.cc}{Scheduler::command}.
These functions are defined in \nsf{tcl/lib/ns-lib.tcl}.
\begin{verbatim}
            % set ns [new Simulator]    # get new instance of simulator
            _o1
            % $ns now                   # query simulator for current time
            0
            % $ns at ...                # specify at operations for simulator
            ...
\end{verbatim}


\section{Class EmbeddedTcl}
\label{sec:EmbeddedTcl}

\ns\ permits the development of functionality in either compiled code,
or through interpreter code, that is evaluated at initialisation.
For example, the scripts \Tclf{tcl-object.tcl} or the scripts in
\nsf{tcl/lib}.
Such loading and evaluation of scripts is done through objects in the
\clsref{EmbeddedTcl}{../Tcl/Tcl.h}.

An EmbeddedTcl object is initialised with an OTcl script converted into an
array of octets.
During initialisation, invoking the method \code{EmebddedTcl::load}
explicitly evaluates the array.

The program, \xref{\Tclf{tcl2cc.c}}{../Tcl/tcl2c++.c.html},
converts OTcl code into an equivalent EmbeddedTcl object.
An example of such OTcl code is \code{tcl-object.tcl},
its equivalent EmbeddedTcl object is \code{embedded-tclobj.cc}.

\xref{\Tclf{tcl-object.tcl}}{../Tcl/tcl-object.tcl} is evaluated by the method
\fcnref{\fcn{Tcl::init}}{../Tcl/Tcl.cc}{Tcl::init}, invoked by \code{Tcl\_AppInit}.
Similarly,
\xref{\nsf{tcl/lib/ns-lib.tcl}}{../ns-2/tcl/lib/ns-lib.tcl}
is evaluated directly by \code{Tcl\_AppInit} in \nsf{ns\_tclsh.cc}.

Two points to note with EmbeddedTcl code are that
firstly, if the code has an error that is caught during the eval,
then \ns\ will not run.
Secondly, the user can explicitly override any of the code in the scripts.
In particular, they can re-source the entire script after making their own
changes. 

\section{Class InstVar}
\label{sec:InstVar}

\danger
This section describes the internals of the \clsref{InstVar}{../Tcl/Tcl.cc}.
The entire section should be considered flagged with danger bends.

In this section, we describe instance variables and how they are set up.
Instance variables are the compiled member
variables that are also accessible through the interpreter.
The class Instvar sets up the binding
between the compiled member variable and the interpreted member variable.
The binding is set up such that the value of the variable can be
set or accessed either from within the interpreter, or from
within the compiled code at all times.

There are five instance variable classes:
\clsref{InstVarReal}{../Tcl/Tcl.cc},
\clsref{InstVarTime}{../Tcl/Tcl.cc},
\clsref{InstVarBandwidth}{../Tcl/Tcl.cc},
\clsref{InstVarInt}{../Tcl/Tcl.cc},
and \clsref{InstVarBool}{../Tcl/Tcl.cc},
corresponding to bindings for real, time, bandwidth, integer, and
boolean valued variables respectively.

We now describe the mechanism by which instance variables are set up.
We use the \clsref{InstVarReal}{../Tcl/Tcl.cc}
to illustrate the concept.
However, this mechanism is applicable to all five types of instance variables.

When setting up an interpreted variable to access a member variable,
the member functions of the class InstVar assume that they are executing
in the appropriate method execution context;
therefore, they do not query the interpreter to determine the context in
which this variable must exist.

In order to guarantee the correct method execution context,
a variable must only be bound if its class is already established within
the interpreter, and
the interpreter is currently operating on an object in that class.
Note that the former requires that when a method in a given class is
going to make its variables accessible via the interpreter,
there must be an associated 
\href{class TclClass}{Section}{sec:TclClass}
defined that identifies the appropriate class hierarchy to the interpreter.
The appropriate method execution context can therefore be created in one
of two ways.

An implicit solution occurs whenever a new TclObject is created within
the interpreter.
This sets up the method execution context within the interpreter.
When the compiled shadow object of the interpreted TclObject is created,
the constructor for that compiled object can bind its member variables
of that object
to interpreted instance variables in the context of the newly created
interpreted object.

An explicit solution is to define a \code{bind-variables} operation
within a \code{command} function, that can then be invoked via the
\code{cmd} method.
The correct method execution context is established in order to execute
the \code{cmd} method.
Likewise, the compiled code is now operating on the appropriate
shadow object, and can therefore safely bind the required member variables.

An instance variable is created by specifying the name of the
interpreted variable, and the address of the member variable in the
compiled object.
The
\fcnref{constructor}{../Tcl/Tcl.cc}{InstVar::InstVar}
for the base class InstVar 
creates an instance of the variable in the interpreter,
and then sets up a
\fcnref{trap routine}{../Tcl/Tcl.cc}{InstVar::catch_var}
to  catch all accesses to the variable through the interpreter.

Whenever the variable is read through the interpreter, the
\fcnref{trap routine}{../Tcl/Tcl.cc}{InstVar::catch_read}
is invoked just prior to the occurrence of the read.
The routine invokes the appropriate
\fcnref{\code{get} function}{../Tcl/Tcl.cc}{InstVarReal::get}
that returns the current value of the variable.
This value is then used to set the value of the interpreted variable
that is then read by the interpreter.

Likewise,
whenever the variable is set through the interpreter, the
\fcnref{trap routine}{../Tcl/Tcl.cc}{InstVar::catch_write}
is invoked just after to the write is completed.
The routine gets the current value set by the interpreter, 
and invokes the appropriate
\fcnref{\code{set} function}{../Tcl/Tcl.cc}{InstVarReal::set}
that sets the value of the compiled member to the current value set
within the interpreter.

\end{document}

### Local Variables:
### mode: latex
### comment-column: 60
### backup-by-copying-when-linked: t
### file-precious-flag: nil
### End:
