%       This draft written by Tom Henderson (8/29/97) based on John Heidemann's
%   code comments.
%
%
% If you get conflicts, here's what you need to keep:  The chapter heading
% in the first entry is essential.  The \endinput at end is useful.
% Other mods are to promote each sub*section one level up.
%
\chapter{\shdr{Timers}{timer-handler.h}{sec:timers}}

Timers may be implemented in C++ or OTcl.  In C++, timers are based on an 
abstract base class defined in \code{timer-handler.h}.  They are most often 
used in agents, but the 
framework is general enough to be used by other objects.  The discussion
below is oriented towards the use of timers in agents.

In OTcl, a simple timer class is defined in \code{tcl/ex/timer.tcl}.  
Subclasses can be derived to provide a simple mechanism for scheduling events 
at the OTcl level.

\section{\shdr{C++ abstract base class TimerHandler}{timer-handler.h}{sec:abstractbaseclass}}

The abstract base class \code{TimerHandler} contains the following public member functions:
\begin{tt}
\begin{quote}
\begin{itemize}
\item[void sched(double delay)] - schedule a timer to expire delay seconds in the future
\item[void resched(double delay)] - reschedule a timer (similar to sched(), but
timer may be pending)
\item[void cancel()] - cancel a pending timer
\item[int status()] - returns timer status (either IDLE, PENDING, or HANDLING)
\end{itemize}
\end{quote}
\end{tt}

The abstract base class \code{TimerHandler} contains the following protected members:
\begin{tt}
\begin{quote}
\begin{itemize}
\item[virtual void expire(Event *e) = 0] - this method must be filled in by the timer client
\item[virtual void handle(Event *e) = 0] - consumes an event 
\item[int status\_] - keeps track of the current timer status
\item[Event event\_] - event to be consumed upon timer expiry 
\end{itemize}
\end{quote}
\end{tt}

The pure virtual functions must be defined by the timer classes deriving
from this abstract base class.

Finally, two private inline functions are defined:
\begin{small}
\begin{verbatim}
        inline void _sched(double delay) {
            (void)Scheduler::instance().schedule(this, &event_, delay);
        }
        inline void _cancel() {
            (void)Scheduler::instance().cancel(&event_);
        }
\end{verbatim}
\end{small}

From this code we can see that timers make use of methods of the 
\code{Scheduler} class.

\subsection{\shdr{Definition of a new timer}{timer-handler.h}{sec:definition}}

To define a new timer, subclass this function and define handle() if needed 
(handle() is not always required):

\begin{small}
\begin{verbatim}

        class MyTimer : public TimerHandler {
        public:
          MyTimer(MyAgentClass *a) : TimerHandler() { a_ = a; }
          virtual double expire(Event *e);
        protected:
          MyAgentClass *a_;
        };

\end{verbatim}
\end{small}

Then define expire:

\begin{small}
\begin{verbatim}

        double
        MyTimer::expire(Event *e)
        {
          // do the work
          // return TIMER_HANDLED;    // => do not reschedule timer
          // return delay;            // => reschedule timer after delay
        }

\end{verbatim}
\end{small}

Note that \code{expire()} can return either the flag TIMER\_HANDLED or a
delay value, depending on the requirements for this timer.

Often \code{MyTimer} will be a friend of \code{MyAgentClass}, or 
\code{expire()} will only call a public function of \code{MyAgentClass}.

Timers are not directly accessible from the OTcl level, although users are
free to establish method bindings if they so desire.

\subsection{\shdr{Example: Tcp retransmission timer}{tcp.cc}{sec:timerexample}}

TCP is an example of an agent which requires timers.  There are three timers
defined in the basic Tahoe TCP agent defined in \code{tcp.cc}:

\begin{small}
\begin{verbatim}
        rtx_timer_;      //  Retransmission timer
        delsnd_timer_;   //  Delays sending of packets by a small random
                             amount of time, to avoid phase effects
        burstsnd_timer_;   // Helps TCP to stagger the transmission of a large
                              window into several smaller bursts
\end{verbatim}
\end{small}

In \code{tcp.h}, three classes are derived from the base class 
\code{TimerHandler}:
\begin{small}
\begin{verbatim}

class RtxTimer : public TimerHandler {
public:
    RtxTimer(TcpAgent *a) : TimerHandler() { a_ = a; }
protected:                   
    virtual void expire(Event *e);
    TcpAgent *a_;
};  
    
class DelSndTimer : public TimerHandler {
public:
    DelSndTimer(TcpAgent *a) : TimerHandler() { a_ = a; }
protected:
    virtual void expire(Event *e);
    TcpAgent *a_;
};      
    
class BurstSndTimer : public TimerHandler {
public: 
    BurstSndTimer(TcpAgent *a) : TimerHandler() { a_ = a; }
protected:
    virtual void expire(Event *e); 
    TcpAgent *a_;
};  

\end{verbatim}
\end{small}

In the constructor for \code{TcpAgent} in \code{tcp.cc}, each of these timers
is initialized with the \code{this} pointer, which is assigned to the pointer
\code{a_}.

\begin{small}
\begin{verbatim}

TcpAgent::TcpAgent() : Agent(PT_TCP), rtt_active_(0), rtt_seq_(-1), 
    ...
    rtx_timer_(this), delsnd_timer_(this), burstsnd_timer_(this)
{
    ...
}

\end{verbatim}
\end{small}

In the following, we will focus only on the retransmission timer.  Various
helper methods may be defined to schedule timer events; \eg,

\begin{small}
\begin{verbatim}

/*
 * Set retransmit timer using current rtt estimate.  By calling resched(),
 * it does not matter whether the timer was already running.
 */
void TcpAgent::set_rtx_timer()
{
    rtx_timer_.resched(rtt_timeout());
}

/*
 * Set new retransmission timer if not all outstanding
 * data has been acked.  Otherwise, if a timer is still
 * outstanding, cancel it.
 */
void TcpAgent::newtimer(Packet* pkt)
{
    hdr_tcp *tcph = (hdr_tcp*)pkt->access(off_tcp_);
    if (t_seqno_ > tcph->seqno())
        set_rtx_timer();
    else if (rtx_timer_.status() == TIMER_PENDING)
        rtx_timer_.cancel();
}

\end{verbatim}
\end{small}

In the above code, the \code{set_rtx_timer()} method reschedules the 
retransmission timer by calling \code{rtx_timer_.resched()}.  Note that if
it is unclear whether or not the timer is already running, calling
\code{resched()} eliminates the need to explicitly cancel the timer.  In
the second function, examples are given of the use of the \code{status()}
and \code{cancel()} methods.

Finally, the \code{expire()} method for class \code{RtxTimer} must be 
defined.  In this case, \code{expire()} calls the \code{timeout()} method
for \code{TcpAgent}.  This is possible because \code{timeout()} is a 
public member function; if it were not, then \code{RtxTimer} would have
had to have been declared a friend class of \code{TcpAgent}.

\begin{small}
\begin{verbatim}

void TcpAgent::timeout(int tno)
{                     
    /* retransmit timer */
    if (tno == TCP_TIMER_RTX) {
        if (highest_ack_ == maxseq_ && !slow_start_restart_) {
            /*
             * TCP option:
             * If no outstanding data, then don't do anything.
             */
            return;  
        };
        recover_ = maxseq_;
        recover_cause_ = 2;
        closecwnd(0);
        reset_rtx_timer(0,1);
        send_much(0, TCP_REASON_TIMEOUT, maxburst_); 
    }       
    else {  
        /*  
         * delayed-send timer, with random overhead
         * to avoid phase effects  
         */     
        send_much(1, TCP_REASON_TIMEOUT, maxburst_);
    }           
}           
            
void RtxTimer::expire(Event *e) {
    a_->timeout(TCP_TIMER_RTX);
}

\end{verbatim}
\end{small}

The various TCP agents contain additional examples of timers.

\section{\shdr{OTcl Timer class}{timer.tcl}{sec:otcltimer}}

A simple timer class is defined in \code{tcl/ex/timer.tcl}.  Subclasses of
\code{Timer} can be defined as needed.  Unlike the C++ timer API, where a 
\code{sched()} aborts if the timer is already set, \code{sched()} and
\code{resched()} are the same; i.e., no state is kept for the OTcl timers.
The following methods are defined in the \code{Timer} base class:
\begin{program}

    $self sched $delay   \; causes "$self timeout" to be called $delay seconds in the future;
    $self resched $delay \; same as "$self sched $delay" ;
    $self cancel         \; cancels any pending scheduled callback;
    $self destroy        \; same as "$self cancel";
    $self expire         \; calls "$self timeout" immediately;

\end{program}

\endinput
