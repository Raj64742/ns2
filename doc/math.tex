%
% personal commentary:
%        DRAFT DRAFT DRAFT
%        - KFALL
%
\section{\shdr{Mathematical Support}{random.h}{sec:math}}

The simulator includes a small collection of mathematical
functions used to implement random variate generation and integration.
This area of the simulator is currently undergoing some
changes.

\subsection{\shdr{Random Number Generation}{rng.h}{sec:random}}

The \code{RNG} class contains an implementation of the minimal standard
multiplicative linear congruential generator of Park, S.K. and
Miller, K.W., "Random Number Generators: Good Ones are Hard to Find,"
CACM 31:10, Oct. 88, pp. 1192-1201.

Multiple instances of the RNG class can be created to allow a
simulation to draw random numbers from independent random number
streams.  For instance, a user who wants to generate the same traffic
(based on some random process) in 2 different simulation experiments
that compare different dropping algorithms that are themselves based
on random processes may choose to base the traffic generation on one
random number stream and the dropping algorithms on another stream.
However, when using multiple RNG objects in a simulation care should
be taken to insure that they are seeded in such a way as to guarantee
that they produce independent streams of random numbers.  Features
will be added in the future to help seed multiple random number
generators properly.

Most users will be satisfied with a single instance of the RNG.
Hence, a default RNG, created at simulator initialization time, is
provided.

\paragraph{C++ Support}
This random number generator is
implemented by the RNG class, defined in rng.h:
\begin{program}
class RNG : public TclObject \{
enum RNGSources \{ RAW_SEED_SOURCE, PREDEF_SEED_SOURCE, HEURISTIC_SEED_SOURCE \};
        ...
        // These are primitive but maybe useful.
        inline int uniform_positive_int() \{  // range [0, MAXINT]
                return (int)(stream_.next());
        \}
        inline double uniform_double() \{ // range [0.0, 1.0)
                return stream_.next_double();
        \}

        inline int uniform(int k)
                \{ return (uniform_positive_int() % (unsigned)k); \}
        inline double uniform(double r) 
                \{ return (r * uniform_double());\}
        inline double uniform(double a, double b)
                \{ return (a + uniform(b - a)); \}
        inline double exponential()
                \{ return (-log(uniform_double())); \}
        inline double exponential(double r)
                \{ return (r * exponential());\}
        inline double pareto(double scale, double shape)
                \{ return (scale * (1.0/pow(uniform_double(), 1.0/shape)));\}
        ...
\};
\end{program}

The \code{uniform_positive_int} method generates random integers in the
range $[0,2^{31}-1]$.
In particular,
Additional member functions provide the following random variate
generation:
\begin{itemize}
        \item {\tt uniform(double r)} - generate floating-point number uniformly distributed on $[0,r]$
        \item {\tt uniform(double a, double b)} - generate floating-point number uniformly distributed on $[a,b]$
        \item {\tt exponential()} - generate floating-point number exponentially distributed (with parameter 1) on $[0, \infty)$
        \item {\tt integer(int k)} - generate integer uniformly distributed on $[0, (k-1)]$
\end{itemize}
The \code{Random} class can be used to construct randomized algorithms,
as in this code fragment from RED:
\begin{program}
        ...
        // drop probability is computed, pick random number and act
        double u = rng_->uniform_double();
        if (u <= edv_.v_prob) {
                edv_.count = 0;
                if (edp_.setbit) 
                        iph->flags() |= IP_ECN; // ip ecn bit
                else
                        return (1);
        }
        \ldots
\end{program}
      

The set of random numbers produced by an RNG object depends on its
initial seed.  The initial seed can be set with the {\tt set\_seed} method
which takes 2 parameters, where the second
defaults to 1.  The first parameter, an enumerated type,
determines how
the seed is generated and the second is a seed value.  There are 3
values of this enumerated type used determine the initial seed value:

\begin{itemize}

\item[RAW\_SEED\_SOURCE]:  the value contained in the second parameter is used
as the seed.

\item [PREDEF\_SEED\_SOURCE]:  the value contained in the second parameter is
used as the index into an array of predefined seed values.  These
values have been precomputed and provide independent streams of random
numbers.  There are currently 64 such seeds.

\item [HEURISTIC\_SEED\_SOURCE]: use a heuristic to generate the seed.
The second argument is ignored if provided.
\end{itemize}

The heuristic seeding method
attempts to pick some sort of non-recurring seed values (resulting
in different random numbers from run to run).  The heuristic implementation
is contained in the file \code{rng.cc}.

\paragraph{OTcl support}
The RNG class can be accessed from OTcl.  For example, a new RNG is
created and seeded with:

\begin{program}
set rng [new RNG]
$rng seed 0 \; seeds the RNG heuristically;
$rng seed n \; seeds the RNG with value n;
$rng next-random \;  return the next random number;
$rng uniform a b \; return a number uniformly distributed on [a, b];
$rng integer k \; return an integer uniformly distributed on [0, (k-1)];
$rng exponential \; return a number from an exponential distribution with average 1.;
\end{program}

\subsection{\shdr{Random Variables}{ranvar.h}{sec:ranvar}}

The RandomVariable class provides a thin layer of functionality on top
of the base random number generator that implements random variates.
It is defined in {\tt ranvar.h}:

\subsection{\shdr{Integrals}{integrator.h}{sec:integral}}

To support the approximation of (continuous) integration by (discrete)
sums, the \code{Integrator} class is defined in \code{integrator.h}:
\begin{small}
\begin{verbatim}
From integrator.h:
        class Integrator : public TclObject {
        public:
                Integrator();
                void set(double x, double y);
                void newPoint(double x, double y);
                int command(int argc, const char*const* argv);
        protected:
                double lastx_;
                double lasty_;
                double sum_;
        };
From integrator.cc:
        Integrator::Integrator() : lastx_(0.), lasty_(0.), sum_(0.)
        {
                bind("lastx_", &lastx_);
                bind("lasty_", &lasty_);
                bind("sum_", &sum_);
        }

        void Integrator::set(double x, double y)
        {
                lastx_ = x;
                lasty_ = y;
                sum_ = 0.;
        }

        void Integrator::newPoint(double x, double y)
        {
                sum_ += (x - lastx_) * lasty_;
                lastx_ = x;
                lasty_ = y;
        }

        int Integrator::command(int argc, const char*const* argv)
        {
                if (argc == 4) {
                        if (strcmp(argv[1], "newpoint") == 0) {
                                double x = atof(argv[2]);
                                double y = atof(argv[3]);
                                newPoint(x, y);
                                return (TCL_OK);
                        }
                }
                return (TclObject::command(argc, argv));
        }
\end{verbatim}
\end{small}
This class provides a base class used by other classes such
as \code{QueueMonitor} that keep running sums.
Each new element of the running sum is added by
the \code{newPoint(x,y)} function.
After the $k$th execution of \code{newPoint}, the running sum
is equal to $\sum_{i=1}^{k}y_{i-1}(x_i - x_{i-1})$ where
$x_0 = y_0 = 0$ unless \code{lastx\_}, \code{lasty\_}, or \code{sum\_}
are reset via OTcl.
Note that a new point in the sum can be added either by the
C++ member \code{newPoint} or the OTcl member \code{newpoint}.
The use of integrals to compute certain types of averages
(e.g. mean queue lengths) is given in Jain(1991, pp. 429-430).
