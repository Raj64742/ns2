\chapter{Session-level Packet Distribution}
\label{chap:session}

This section describes the internals of the Session-level Packet Distribution
implementation in \ns.
The section is in two parts:
the first part is an overview of 
\href{Session configuration}{Section}{sec:config},
and a ``complete'' description of the configuration parameters 
of a Session.
The second part describes the architecture, internals, and the code path
of the Session-level Packet distribution.

The procedures and functions described in this chapter can be found in
\nsf{tcl/session/session.tcl}.

Session-level Packet Distribution is oriented towards
performing multicast simulations over large topologies.
The memory requirements for some topologies using
session level simulations are:

\begin{tabular}{r @{~~~$approx$~} r@{\,MB}}
2048 nodes, degree of connectivity = 8 & $\approx$ 40 \\
2049--4096 nodes & 167 \\
4097--8194 nodes & 671 \\
\end{tabular}

Note however, that session level simulations ignore qeueing and
propagation delays.
Therefore, the accuracy of
simulations that use sources with a high data rate,
or those that use multiple sources that get aggregated at points
within the network is suspect.

\section{Configuration}
\label{sec:config}

Configuration of a session level simulation consists of two parts,
\href{configuration of the session level details themselves}{Section}{%
	sec:basic-config}
and 
\href{adding loss and error models to the session level abstraction
to model specific behaviours}{Section}{sec:loss-config}.

\subsection{Basic Configuration}
\label{sec:basic-config}

The basic configuration consists of creating and configuring
a  multicast session.
Each Session (\ie, a multicast tree) must be configured strictly in
this order:
(1) create and configure the session source,
(2) create the session helper and attach it to the session source, and
finally, (3) have the session members join the session.
\begin{program}
        set ns [new SessionSim]          \; preamble initialization;
        set node [$ns node]    
        set group [$ns allocaddr]

        set src [new Agent/CBR]		\; create and configure the source;
        $src set dst_ $group
        $ns attach-agent $node $src

        $ns create-session $node $src   \; create attach session helper to src;

        set rcvr [new Agent/NULL]        \; configure the receiver;
        $ns attach-agent $node $rcvr
        $ns at 0.0 "$node join-group $rcvr $group" \; joining the session;

        $ns at 0.1 "$src start"
\end{program}
A session level simulation scales by translating the topology
into a virtual mesh topology.
The steps involved in doing this are:
\begin{enumerate}\itemsep0pt
\item All of the classifiers and replicators are eliminated.
  Each node only stores instance variables to track its node id, and port ids.
\item Links do not consist of multiple components.
  Each link only stores instance variables to track the bandwidth and delay attributes.
\item The topology, consisting of links is translated into a virtual mesh.
\end{enumerate}
Figure~\ref{fig:conversions} shows the difference between a
multicast tree in a detailed simulation and one in a session level simulation.
Notice that the translation process results in a session level simulation
ignoring queueing delays.
For most simulations, \ns\ already ignores processing delays at all of the nodes.

\subsection{Inserting a Loss Module}
\label{sec:loss-config}

When studying a protocol (\eg, SRM error recovery mechanism), 
it might be useful to study protocol behaviour over lossy links.
However, since a session level simulation scales by abstracting 
out the internal topology,
we need additional mechanisms to insert a loss module appropriately.
This subsection describes how one can create these loss modules to
model error scenarios.

%Please note that packets dropped at a particular link in a
%multicast tree will not be received by
%the receivers in the particular downstream subtree. We have worked 
%on this dependency problem and now the loss modules for the downstream 
%receivers will be installed automatically when a lossy link is created.

\paragraph{Creating a Loss Module}
Before we can insert a loss module in between a source-receiver pair,
we have to create the loss module.  Basically,
a loss module compares two values to decide whether to drop a packet.
The first value is obtained every time when the loss module receives 
a packet from a random variable.  The second value
is fixed and configured when the loss module is created.

The following code gives an example to create a uniform 0.1 loss rate.
\begin{program}
        # {\cf creating the uniform distribution random variable}
        set loss_random_variable [new RandomVariable/Uniform] 
        $loss_random_variable set min_ 0 \; set the range of the random variable;
        $loss_random_variable set max_ 100

        set loss_module [new ErrorModel] \; create the error model;
        $loss_module drop-target [new Agent/Null] 
        $loss_module set rate_ 10 \; set error rate to \(0.1 = 10 / (100 - 0)\);
        $loss_module ranvar $loss_random_variable \; attach random var. to loss module;
\end{program}
\href{A catalogue of the random variable distributions was described earlier}{%
	Chapter}{chap:math}.
\href{A more detailed discussion of error models was also described earlier
in a different chapter}{Chapter}{chap:error_model}.

\paragraph{Inserting a Loss Module}
A loss module can only be inserted after the corresponding receiver
has joined the group.  The example code below illustrates how
a simulation script can introduce a loss module.
\begin{program}
        set sessionhelper [$ns create-session $node $src] \; keep a handle to the loss module;
        $ns at 0.1 "$sessionhelper insert-depended-loss $loss_module $rcvr" 
\end{program}

\section{Architecture}
\label{sec:session-arch}
The purpose of Session-level packet distribution is to
speed up simulations and reduce memory consumption while 
maintaining reasonable accuracy.
The first bottleneck observed is the memory consumption by heavy-weight
links and nodes.  Therefore, in SessionSim (Simulator for Session-level
packet distribution), we keep only minimal amount of 
states for links and nodes, and connect the higher level source and 
receiver applications with appropriate delay and loss modules.
A particular source in a group sends its data packets
to a replicator that is responsible for replicating the packets
for all the receivers.
Intermediate loss and delay modules between this replicator and the receivers
will guarantee the appropriate end-to-end characteristics.
To put it another way, a session level simulation
abstracts out the topology, routing and queueing delays.
Packets in SessionSim do not get routed.  
They only follow the established Session.

\section{Internals}
This section describes the internals of Session-level Packet Distribution.
The implementation is split into two parts:
\begin{list}{}{}
\item  Linkage of objects to make a Session in OTcl 
\item  Packet forwarding activities are executed by C++ methods.  
\end{list}

\subsection{Object Linkage}
\label{sec:session-objlink}

\begin{list}{}{}
\item  Simplified links and nodes.
\item  Replicator
\item  Delay and loss modules
\end{list}

\paragraph{Nodes and Links}
A link only contains the values of
its bandwidth and delay, and a node contains only its id and port number
for next agent.

\begin{program}
SessionSim instproc simplex-link \{ n1 n2 bw delay type \} \{
    $self instvar bw_ delay_
    set sid [$n1 id]
    set did [$n2 id]

    set bw_($sid:$did) [expr [string trimright $bw Mb] * 1000000]
    set delay_($sid:$did) [expr [string trimright $delay ms] * 0.001]
\}

SessionNode instproc init \{\} \{
    $self instvar id_ np_
    set id_ [Node getid]
    set np_ 0
\}
\end{program}

\paragraph{Replicator}
One replicator is required per source.  While the source is configured,
a replicator (session helper) need to be attached to the source.  By
calling \proc[]{create-session}, a replicator is:
created,
attached to the source application, and 
kept in a SessionSim instance variable \code{session_} array with 
its source and destination addresses as the index.

Note that the destination of source agent must be set before
calling \proc[]{create-session}.

\begin{program}
SessionSim instproc create-session \{ node agent \} \{
    $self instvar session_

    set nid [$node id]
    set dst [$agent set dst_]
    set session_($nid:$dst) [new Classifier/Replicator/Demuxer]
    $agent target $session_($nid:$dst) \; attach the replicator to the source;
    return $session_($nid:$dst) \; keep the replicator in the SessionSim instance variable array \code{session_};
\}
\end{program}

\paragraph{Delay and Loss Modules}

At least one delay module is required per receiver.
See Section~\ref{sec:loss-config} for inserting a loss module for a receiver.
When a receiver joins a group, 
the \proc[]{join-group} method goes through
all replicators (session helpers) maintained in \code{session_}.
If the destination index matches the group address
the receiver are joining, then the following actions are performed.

1. A new slot of the replicator (session helper) is created and assigned to the receiver.

2. An accumulated bandwidth and delay between the source and receiver are obtained by SessionSim instance procedure \proc[]{get-bw} and \proc[]{get-delay}.

3. A constant random variable is created and assigned with the
accumulative delay.

4. A delay module is created and assigned with the constant random 
variable and the accumulative bandwidth.

5. The delay module in inserted into the replicator slot in
front of the receiver.

\begin{program}
SessionSim instproc join-group \{ agent group \} \{
    $self instvar session_

    foreach index [array names session_] \{
        set pair [split $index :]
        if \{[lindex $pair 1] == $group\} \{
            # Note: must insert the chain of loss, delay, 
            # and destination agent in this order:

            #1. insert destination agent into session replicator
            $session_($index) insert $agent

            #2. find accumulative bandwidth and delay
            set src [lindex $pair 0]
            set dst [[$agent set node_] id]
            set accu_bw [$self get-bw $dst $src]
            set delay [$self get-delay $dst $src]

            #3. set up a constant delay random variable
            set random_variable [new RandomVariable/Constant]
            $random_variable set avg_ $delay

            #4. set up the delay module
            set delay_module [new DelayModel]
            $delay_module bandwidth $accu_bw
            $delay_module ranvar $random_variable

            #5. insert the delay module in front of the dest agent
            $session_($index) insert-module $delay_module $agent
        \}
    \}
\}
\end{program}


\subsection{Packet Forwarding}
\label{sec:session-pktforward}
Packet forwarding activities are executed in C++.  A source application 
generates a packet and forwards to its target which must be a replicator 
(session helper).  The replicator copies the packet and forwards 
to targets in the active slots which are either delay modules or loss modules. If loss modules, a decision is made whether to drop the packet.
If yes, the packet is forwarded to the loss modules drop target.  If not,
the loss module forwards it to its target which must be a delay module.
The delay module will forward the packet with a delay to its target which
must be a receiver application.
\begin{figure}[tb]
  \centerline{\includegraphics{sessionArch}}
  \caption{Architectural Realisation of a Session Level Simulation Session}
  \label{fig:session}
\end{figure}

\endinput

### Local Variables:
### mode: latex
### comment-column: 60
### backup-by-copying-when-linked: t
### file-precious-flag: nil
### End:
